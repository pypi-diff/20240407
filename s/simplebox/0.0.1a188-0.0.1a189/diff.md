# Comparing `tmp/simplebox-0.0.1a188-py3-none-any.whl.zip` & `tmp/simplebox-0.0.1a189-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,31 +1,32 @@
-Zip file size: 182916 bytes, number of entries: 129
--rw-rw-rw-  2.0 fat     5191 b- defN 24-Apr-05 16:33 simplebox/__init__.py
--rw-rw-rw-  2.0 fat     2063 b- defN 23-May-03 14:56 simplebox/backend.py
--rw-rw-rw-  2.0 fat    17591 b- defN 23-Sep-09 14:25 simplebox/character.py
--rw-rw-rw-  2.0 fat     4847 b- defN 23-Jun-28 13:14 simplebox/classes.py
--rw-rw-rw-  2.0 fat    16948 b- defN 23-May-19 15:15 simplebox/cmd.py
+Zip file size: 183657 bytes, number of entries: 131
+-rw-rw-rw-  2.0 fat     5191 b- defN 24-Apr-07 13:57 simplebox/__init__.py
+-rw-rw-rw-  2.0 fat     2090 b- defN 24-Apr-07 16:46 simplebox/backend.py
+-rw-rw-rw-  2.0 fat    17626 b- defN 24-Apr-07 16:46 simplebox/character.py
+-rw-rw-rw-  2.0 fat     4825 b- defN 24-Apr-07 14:50 simplebox/classes.py
+-rw-rw-rw-  2.0 fat    16962 b- defN 24-Apr-07 16:46 simplebox/cmd.py
 -rw-rw-rw-  2.0 fat     5481 b- defN 23-Nov-14 15:01 simplebox/converter.py
--rw-rw-rw-  2.0 fat     1644 b- defN 23-Nov-13 15:48 simplebox/enums.py
+-rw-rw-rw-  2.0 fat     1638 b- defN 24-Apr-07 15:02 simplebox/enums.py
 -rw-rw-rw-  2.0 fat      306 b- defN 23-May-31 16:53 simplebox/generic.py
--rw-rw-rw-  2.0 fat    55407 b- defN 24-Apr-01 16:23 simplebox/http.py
+-rw-rw-rw-  2.0 fat    55432 b- defN 24-Apr-07 16:46 simplebox/http.py
 -rw-rw-rw-  2.0 fat     3672 b- defN 23-Sep-07 15:33 simplebox/jsonparser.py
--rw-rw-rw-  2.0 fat    20248 b- defN 24-Mar-28 16:21 simplebox/number.py
--rw-rw-rw-  2.0 fat      772 b- defN 23-Apr-18 14:44 simplebox/singleton.py
--rw-rw-rw-  2.0 fat     4768 b- defN 23-Sep-17 12:41 simplebox/void.py
--rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 11:52 simplebox/_handler/__init__.py
+-rw-rw-rw-  2.0 fat    20276 b- defN 24-Apr-07 14:31 simplebox/number.py
+-rw-rw-rw-  2.0 fat     1006 b- defN 24-Apr-07 17:05 simplebox/singleton.py
+-rw-rw-rw-  2.0 fat     1400 b- defN 24-Apr-07 17:02 simplebox/version.py
+-rw-rw-rw-  2.0 fat     4777 b- defN 24-Apr-07 14:13 simplebox/void.py
+-rw-rw-rw-  2.0 fat       47 b- defN 24-Apr-07 16:21 simplebox/_handler/__init__.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 11:52 simplebox/_handler/_backend_handler/__init__.py
--rw-rw-rw-  2.0 fat     8148 b- defN 24-Mar-29 15:48 simplebox/_handler/_backend_handler/_backend.py
+-rw-rw-rw-  2.0 fat     8180 b- defN 24-Apr-07 16:46 simplebox/_handler/_backend_handler/_backend.py
 -rw-rw-rw-  2.0 fat      979 b- defN 23-Apr-23 15:29 simplebox/_handler/_backend_handler/_run.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 14:37 simplebox/_handler/_converter_handler/__init__.py
 -rw-rw-rw-  2.0 fat      741 b- defN 23-Sep-07 16:22 simplebox/_handler/_converter_handler/_calculator.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 14:02 simplebox/_handler/_number_handler/__init__.py
 -rw-rw-rw-  2.0 fat     1024 b- defN 23-May-03 14:02 simplebox/_handler/_number_handler/_compare.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 05:00 simplebox/_handler/_str_handler/__init__.py
--rw-rw-rw-  2.0 fat    19637 b- defN 23-Sep-08 13:39 simplebox/_handler/_str_handler/_strings.py
+-rw-rw-rw-  2.0 fat    19634 b- defN 24-Apr-07 14:27 simplebox/_handler/_str_handler/_strings.py
 -rw-rw-rw-  2.0 fat      927 b- defN 24-Apr-01 15:44 simplebox/_hyper/__init__.py
 -rw-rw-rw-  2.0 fat     7332 b- defN 24-Apr-01 16:11 simplebox/_hyper/cli.py
 -rw-rw-rw-  2.0 fat     1746 b- defN 24-Apr-01 16:11 simplebox/_hyper/compat.py
 -rw-rw-rw-  2.0 fat     7259 b- defN 24-Apr-01 16:45 simplebox/_hyper/contrib.py
 -rw-rw-rw-  2.0 fat     4561 b- defN 24-Apr-01 16:02 simplebox/_hyper/httplib_compat.py
 -rw-rw-rw-  2.0 fat    10464 b- defN 24-Apr-01 15:44 simplebox/_hyper/ssl_compat.py
 -rw-rw-rw-  2.0 fat     5282 b- defN 24-Apr-01 15:39 simplebox/_hyper/tls.py
@@ -33,37 +34,38 @@
 -rw-rw-rw-  2.0 fat     8570 b- defN 24-Apr-01 15:44 simplebox/_hyper/common/bufsocket.py
 -rw-rw-rw-  2.0 fat     6700 b- defN 24-Apr-01 15:44 simplebox/_hyper/common/connection.py
 -rw-rw-rw-  2.0 fat     1608 b- defN 24-Apr-01 15:39 simplebox/_hyper/common/decoder.py
 -rw-rw-rw-  2.0 fat     2088 b- defN 24-Apr-01 15:44 simplebox/_hyper/common/exceptions.py
 -rw-rw-rw-  2.0 fat     9144 b- defN 24-Apr-01 16:17 simplebox/_hyper/common/headers.py
 -rw-rw-rw-  2.0 fat     1587 b- defN 24-Apr-01 16:17 simplebox/_hyper/common/util.py
 -rw-rw-rw-  2.0 fat      108 b- defN 24-Apr-01 15:39 simplebox/_hyper/http11/__init__.py
--rw-rw-rw-  2.0 fat    17414 b- defN 24-Apr-01 15:44 simplebox/_hyper/http11/connection.py
+-rw-rw-rw-  2.0 fat    17418 b- defN 24-Apr-07 14:10 simplebox/_hyper/http11/connection.py
 -rw-rw-rw-  2.0 fat     2679 b- defN 24-Apr-01 15:44 simplebox/_hyper/http11/parser.py
 -rw-rw-rw-  2.0 fat    13165 b- defN 24-Apr-01 15:44 simplebox/_hyper/http11/response.py
 -rw-rw-rw-  2.0 fat      106 b- defN 24-Apr-01 15:39 simplebox/_hyper/http20/__init__.py
 -rw-rw-rw-  2.0 fat    34497 b- defN 24-Apr-01 15:44 simplebox/_hyper/http20/connection.py
 -rw-rw-rw-  2.0 fat     3328 b- defN 24-Apr-01 15:39 simplebox/_hyper/http20/errors.py
 -rw-rw-rw-  2.0 fat     1095 b- defN 24-Apr-01 15:44 simplebox/_hyper/http20/exceptions.py
 -rw-rw-rw-  2.0 fat     8315 b- defN 24-Apr-01 15:44 simplebox/_hyper/http20/response.py
 -rw-rw-rw-  2.0 fat    12428 b- defN 24-Apr-01 15:44 simplebox/_hyper/http20/stream.py
 -rw-rw-rw-  2.0 fat     1652 b- defN 24-Apr-01 15:44 simplebox/_hyper/http20/util.py
 -rw-rw-rw-  2.0 fat     6309 b- defN 24-Apr-01 15:39 simplebox/_hyper/http20/window.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-Mar-04 09:59 simplebox/_internal/__init__.py
--rw-rw-rw-  2.0 fat     1137 b- defN 23-Sep-04 16:02 simplebox/_internal/_argparser.py
--rw-rw-rw-  2.0 fat     2618 b- defN 23-Jun-26 15:08 simplebox/_internal/_banner.py
--rw-rw-rw-  2.0 fat     3532 b- defN 23-May-17 13:35 simplebox/_internal/_method_helper.py
+-rw-rw-rw-  2.0 fat     1112 b- defN 24-Apr-07 14:40 simplebox/_internal/_argparser.py
+-rw-rw-rw-  2.0 fat     2587 b- defN 24-Apr-07 14:40 simplebox/_internal/_banner.py
+-rw-rw-rw-  2.0 fat     3515 b- defN 24-Apr-07 16:46 simplebox/_internal/_method_helper.py
+-rw-rw-rw-  2.0 fat      311 b- defN 24-Apr-07 16:56 simplebox/_pypkg/__init__.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-02 13:27 simplebox/cache/__init__.py
 -rw-rw-rw-  2.0 fat     1065 b- defN 23-Apr-18 14:28 simplebox/cache/cache.py
--rw-rw-rw-  2.0 fat     7482 b- defN 23-May-03 14:41 simplebox/cache/manager.py
+-rw-rw-rw-  2.0 fat     7476 b- defN 24-Apr-07 14:40 simplebox/cache/manager.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 14:04 simplebox/collection/__init__.py
--rw-rw-rw-  2.0 fat     4098 b- defN 23-Jun-20 13:24 simplebox/collection/array.py
--rw-rw-rw-  2.0 fat     4618 b- defN 23-Jun-20 13:24 simplebox/collection/arraylist.py
--rw-rw-rw-  2.0 fat    18273 b- defN 23-May-03 14:12 simplebox/collection/collections.py
--rw-rw-rw-  2.0 fat     8841 b- defN 24-Jan-05 15:03 simplebox/collection/collectors.py
+-rw-rw-rw-  2.0 fat     4121 b- defN 24-Apr-07 16:46 simplebox/collection/array.py
+-rw-rw-rw-  2.0 fat     4642 b- defN 24-Apr-07 16:46 simplebox/collection/arraylist.py
+-rw-rw-rw-  2.0 fat    18303 b- defN 24-Apr-07 16:46 simplebox/collection/collections.py
+-rw-rw-rw-  2.0 fat     8878 b- defN 24-Apr-07 16:46 simplebox/collection/collectors.py
 -rw-rw-rw-  2.0 fat      112 b- defN 23-Mar-29 14:55 simplebox/colors/__init__.py
 -rw-rw-rw-  2.0 fat      823 b- defN 23-Jun-28 13:21 simplebox/colors/_crayon.py
 -rw-rw-rw-  2.0 fat      980 b- defN 23-Mar-29 13:33 simplebox/colors/_linux.py
 -rw-rw-rw-  2.0 fat     1047 b- defN 23-Apr-14 15:43 simplebox/colors/_unknown.py
 -rw-rw-rw-  2.0 fat     1329 b- defN 23-Mar-29 13:33 simplebox/colors/_windows.py
 -rw-rw-rw-  2.0 fat      140 b- defN 23-May-21 14:14 simplebox/config/__init__.py
 -rw-rw-rw-  2.0 fat    10063 b- defN 23-Sep-11 15:21 simplebox/config/log.py
@@ -72,60 +74,60 @@
 -rw-rw-rw-  2.0 fat      529 b- defN 23-Apr-18 14:28 simplebox/config/show.py
 -rw-rw-rw-  2.0 fat      814 b- defN 24-Apr-04 15:04 simplebox/db/__init__.py
 -rw-rw-rw-  2.0 fat       47 b- defN 24-Apr-04 16:21 simplebox/db/relational/__init__.py
 -rw-rw-rw-  2.0 fat      420 b- defN 24-Apr-06 14:05 simplebox/db/relational/origin/__init__.py
 -rw-rw-rw-  2.0 fat     3150 b- defN 24-Apr-06 14:05 simplebox/db/relational/origin/_db.py
 -rw-rw-rw-  2.0 fat     2157 b- defN 24-Apr-06 14:05 simplebox/db/relational/origin/_mysql.py
 -rw-rw-rw-  2.0 fat     2171 b- defN 24-Apr-06 14:05 simplebox/db/relational/origin/_oracle.py
--rw-rw-rw-  2.0 fat     3336 b- defN 24-Apr-06 14:05 simplebox/db/relational/origin/_query.py
+-rw-rw-rw-  2.0 fat     3340 b- defN 24-Apr-07 16:46 simplebox/db/relational/origin/_query.py
 -rw-rw-rw-  2.0 fat     1766 b- defN 24-Apr-06 14:05 simplebox/db/relational/origin/_sqlite.py
 -rw-rw-rw-  2.0 fat      256 b- defN 24-Apr-06 14:05 simplebox/db/relational/orm/__init__.py
--rw-rw-rw-  2.0 fat     8540 b- defN 24-Apr-06 14:05 simplebox/db/relational/orm/_db.py
+-rw-rw-rw-  2.0 fat     8522 b- defN 24-Apr-07 15:18 simplebox/db/relational/orm/_db.py
 -rw-rw-rw-  2.0 fat     1154 b- defN 24-Apr-06 14:05 simplebox/db/relational/orm/_mysql.py
 -rw-rw-rw-  2.0 fat     1161 b- defN 24-Apr-06 14:05 simplebox/db/relational/orm/_oracle.py
 -rw-rw-rw-  2.0 fat     1082 b- defN 24-Apr-06 14:05 simplebox/db/relational/orm/_sqlite.py
--rw-rw-rw-  2.0 fat     2841 b- defN 23-Sep-06 14:01 simplebox/decorators/__init__.py
--rw-rw-rw-  2.0 fat     7423 b- defN 23-Sep-11 12:59 simplebox/decorators/_around.py
+-rw-rw-rw-  2.0 fat     2810 b- defN 24-Apr-07 15:18 simplebox/decorators/__init__.py
+-rw-rw-rw-  2.0 fat     7425 b- defN 24-Apr-07 16:46 simplebox/decorators/_around.py
 -rw-rw-rw-  2.0 fat      873 b- defN 23-Apr-18 14:40 simplebox/decorators/_cache.py
--rw-rw-rw-  2.0 fat     2449 b- defN 23-May-07 11:51 simplebox/decorators/_capture.py
--rw-rw-rw-  2.0 fat     2245 b- defN 23-Apr-06 14:05 simplebox/decorators/_hook.py
--rw-rw-rw-  2.0 fat     9273 b- defN 23-May-08 10:57 simplebox/decorators/_loop.py
--rw-rw-rw-  2.0 fat     2594 b- defN 23-Jun-26 14:29 simplebox/decorators/_process.py
--rw-rw-rw-  2.0 fat     9348 b- defN 23-May-21 14:18 simplebox/decorators/_properties.py
--rw-rw-rw-  2.0 fat     5160 b- defN 23-May-08 11:08 simplebox/decorators/_scheduler.py
--rw-rw-rw-  2.0 fat     9309 b- defN 23-May-08 11:08 simplebox/decorators/_shape.py
--rw-rw-rw-  2.0 fat     2814 b- defN 23-Sep-11 15:49 simplebox/decorators/_simplelog.py
+-rw-rw-rw-  2.0 fat     2443 b- defN 24-Apr-07 16:46 simplebox/decorators/_capture.py
+-rw-rw-rw-  2.0 fat     2258 b- defN 24-Apr-07 16:46 simplebox/decorators/_hook.py
+-rw-rw-rw-  2.0 fat     9269 b- defN 24-Apr-07 16:46 simplebox/decorators/_loop.py
+-rw-rw-rw-  2.0 fat     2584 b- defN 24-Apr-07 15:18 simplebox/decorators/_process.py
+-rw-rw-rw-  2.0 fat     9288 b- defN 24-Apr-07 15:18 simplebox/decorators/_properties.py
+-rw-rw-rw-  2.0 fat     5149 b- defN 24-Apr-07 16:46 simplebox/decorators/_scheduler.py
+-rw-rw-rw-  2.0 fat     9317 b- defN 24-Apr-07 16:46 simplebox/decorators/_shape.py
+-rw-rw-rw-  2.0 fat     2803 b- defN 24-Apr-07 16:46 simplebox/decorators/_simplelog.py
 -rw-rw-rw-  2.0 fat     1334 b- defN 23-Apr-18 15:09 simplebox/decorators/_singleton.py
--rw-rw-rw-  2.0 fat     3616 b- defN 23-May-20 01:49 simplebox/decorators/_ticker.py
--rw-rw-rw-  2.0 fat     1266 b- defN 23-Mar-23 14:33 simplebox/decorators/_tools.py
--rw-rw-rw-  2.0 fat     7102 b- defN 23-May-19 15:38 simplebox/decorators/_validate.py
+-rw-rw-rw-  2.0 fat     3624 b- defN 24-Apr-07 16:46 simplebox/decorators/_ticker.py
+-rw-rw-rw-  2.0 fat     1241 b- defN 24-Apr-07 15:48 simplebox/decorators/_tools.py
+-rw-rw-rw-  2.0 fat     7098 b- defN 24-Apr-07 16:46 simplebox/decorators/_validate.py
 -rw-rw-rw-  2.0 fat      399 b- defN 24-Apr-05 15:50 simplebox/exceptions/__init__.py
--rw-rw-rw-  2.0 fat     3403 b- defN 24-Apr-05 15:50 simplebox/exceptions/_exceptions.py
+-rw-rw-rw-  2.0 fat     3405 b- defN 24-Apr-07 16:46 simplebox/exceptions/_exceptions.py
 -rw-rw-rw-  2.0 fat      189 b- defN 23-May-21 12:22 simplebox/log/__init__.py
--rw-rw-rw-  2.0 fat    10691 b- defN 23-Dec-19 14:40 simplebox/log/_factory.py
+-rw-rw-rw-  2.0 fat    10666 b- defN 24-Apr-07 15:48 simplebox/log/_factory.py
 -rw-rw-rw-  2.0 fat      648 b- defN 23-May-21 14:18 simplebox/log/_filter.py
 -rw-rw-rw-  2.0 fat     4266 b- defN 23-Sep-11 15:28 simplebox/log/_handler.py
 -rw-rw-rw-  2.0 fat      143 b- defN 24-Mar-28 14:44 simplebox/maps/__init__.py
 -rw-rw-rw-  2.0 fat     6047 b- defN 24-Mar-29 14:41 simplebox/maps/_dictionary.py
--rw-rw-rw-  2.0 fat     3504 b- defN 23-Jun-16 13:17 simplebox/maps/_hash_map.py
--rw-rw-rw-  2.0 fat     3756 b- defN 23-May-03 15:05 simplebox/maps/_map.py
+-rw-rw-rw-  2.0 fat     3500 b- defN 24-Apr-07 16:46 simplebox/maps/_hash_map.py
+-rw-rw-rw-  2.0 fat     3752 b- defN 24-Apr-07 16:46 simplebox/maps/_map.py
 -rw-rw-rw-  2.0 fat      225 b- defN 23-Mar-23 14:59 simplebox/scheduler/__init__.py
 -rw-rw-rw-  2.0 fat     2120 b- defN 23-Mar-20 14:33 simplebox/scheduler/_base.py
--rw-rw-rw-  2.0 fat     5879 b- defN 23-Mar-20 16:02 simplebox/scheduler/_sched.py
--rw-rw-rw-  2.0 fat     6024 b- defN 23-May-18 15:04 simplebox/scheduler/_ticker.py
+-rw-rw-rw-  2.0 fat     5868 b- defN 24-Apr-07 16:46 simplebox/scheduler/_sched.py
+-rw-rw-rw-  2.0 fat     6032 b- defN 24-Apr-07 16:46 simplebox/scheduler/_ticker.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-Mar-20 13:52 simplebox/scheduler/_cron/__init__.py
 -rw-rw-rw-  2.0 fat      226 b- defN 23-Mar-20 13:52 simplebox/scheduler/_cron/_expressions.py
 -rw-rw-rw-  2.0 fat      783 b- defN 23-Mar-25 15:32 simplebox/scheduler/_cron/_fields.py
 -rw-rw-rw-  2.0 fat       47 b- defN 23-May-03 14:12 simplebox/utils/__init__.py
--rw-rw-rw-  2.0 fat    14668 b- defN 23-Jun-26 15:04 simplebox/utils/computer.py
--rw-rw-rw-  2.0 fat     2179 b- defN 23-May-03 15:05 simplebox/utils/enums.py
--rw-rw-rw-  2.0 fat     3008 b- defN 23-Sep-19 16:58 simplebox/utils/locks.py
--rw-rw-rw-  2.0 fat    11990 b- defN 24-Mar-29 15:53 simplebox/utils/objects.py
--rw-rw-rw-  2.0 fat     3221 b- defN 23-May-20 10:14 simplebox/utils/optionals.py
--rw-rw-rw-  2.0 fat    19531 b- defN 23-Sep-08 13:57 simplebox/utils/strings.py
+-rw-rw-rw-  2.0 fat    14714 b- defN 24-Apr-07 16:46 simplebox/utils/computer.py
+-rw-rw-rw-  2.0 fat     2173 b- defN 24-Apr-07 15:48 simplebox/utils/enums.py
+-rw-rw-rw-  2.0 fat     2997 b- defN 24-Apr-07 15:48 simplebox/utils/locks.py
+-rw-rw-rw-  2.0 fat    11999 b- defN 24-Apr-07 15:48 simplebox/utils/objects.py
+-rw-rw-rw-  2.0 fat     3242 b- defN 24-Apr-07 16:46 simplebox/utils/optionals.py
+-rw-rw-rw-  2.0 fat    19546 b- defN 24-Apr-07 15:48 simplebox/utils/strings.py
 -rw-rw-rw-  2.0 fat      247 b- defN 23-Feb-28 15:31 simplebox/valid/__init__.py
--rw-rw-rw-  2.0 fat    14663 b- defN 23-May-03 14:37 simplebox/valid/_validator.py
--rw-rw-rw-  2.0 fat     1390 b- defN 24-Apr-06 14:07 simplebox-0.0.1a188.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-06 14:07 simplebox-0.0.1a188.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       10 b- defN 24-Apr-06 14:07 simplebox-0.0.1a188.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat    11305 b- defN 24-Apr-06 14:07 simplebox-0.0.1a188.dist-info/RECORD
-129 files, 632782 bytes uncompressed, 165008 bytes compressed:  73.9%
+-rw-rw-rw-  2.0 fat    14668 b- defN 24-Apr-07 15:51 simplebox/valid/_validator.py
+-rw-rw-rw-  2.0 fat     1390 b- defN 24-Apr-07 17:05 simplebox-0.0.1a189.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-07 17:05 simplebox-0.0.1a189.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       10 b- defN 24-Apr-07 17:05 simplebox-0.0.1a189.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat    11467 b- defN 24-Apr-07 17:05 simplebox-0.0.1a189.dist-info/RECORD
+131 files, 634967 bytes uncompressed, 165501 bytes compressed:  73.9%
```

## zipnote {}

```diff
@@ -30,14 +30,17 @@
 
 Filename: simplebox/number.py
 Comment: 
 
 Filename: simplebox/singleton.py
 Comment: 
 
+Filename: simplebox/version.py
+Comment: 
+
 Filename: simplebox/void.py
 Comment: 
 
 Filename: simplebox/_handler/__init__.py
 Comment: 
 
 Filename: simplebox/_handler/_backend_handler/__init__.py
@@ -153,14 +156,17 @@
 
 Filename: simplebox/_internal/_banner.py
 Comment: 
 
 Filename: simplebox/_internal/_method_helper.py
 Comment: 
 
+Filename: simplebox/_pypkg/__init__.py
+Comment: 
+
 Filename: simplebox/cache/__init__.py
 Comment: 
 
 Filename: simplebox/cache/cache.py
 Comment: 
 
 Filename: simplebox/cache/manager.py
@@ -369,20 +375,20 @@
 
 Filename: simplebox/valid/__init__.py
 Comment: 
 
 Filename: simplebox/valid/_validator.py
 Comment: 
 
-Filename: simplebox-0.0.1a188.dist-info/METADATA
+Filename: simplebox-0.0.1a189.dist-info/METADATA
 Comment: 
 
-Filename: simplebox-0.0.1a188.dist-info/WHEEL
+Filename: simplebox-0.0.1a189.dist-info/WHEEL
 Comment: 
 
-Filename: simplebox-0.0.1a188.dist-info/top_level.txt
+Filename: simplebox-0.0.1a189.dist-info/top_level.txt
 Comment: 
 
-Filename: simplebox-0.0.1a188.dist-info/RECORD
+Filename: simplebox-0.0.1a189.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## simplebox/__init__.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-__version__ = "0.0.1.alpha188"
+__version__ = "0.0.1.alpha189"
 
 banner = f"""
  .----------------.  .----------------.  .----------------.  .----------------.  .----------------.  .----------------.  .----------------.  .----------------.  .----------------. 
 | .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || .--------------. || .--------------. |
 | |    _______   | || |     _____    | || | ____    ____ | || |   ______     | || |   _____      | || |  _________   | || |   ______     | || |     ____     | || |  ____  ____  | |
 | |   /  ___  |  | || |    |_   _|   | || ||_   \  /   _|| || |  |_   __ \   | || |  |_   _|     | || | |_   ___  |  | || |  |_   _ \    | || |   .'    `.   | || | |_  _||_  _| | |
 | |  |  (__ \_|  | || |      | |     | || |  |   \/   |  | || |    | |__) |  | || |    | |       | || |   | |_  \_|  | || |    | |_) |   | || |  /  .--.  \  | || |   \ \  / /   | |
```

## simplebox/backend.py

```diff
@@ -1,20 +1,21 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from pathlib import Path
-from typing import Callable, Iterable, Dict
+from ._pypkg import Callable
+from collections.abc import Iterable
 
 from ._handler._backend_handler._backend import _Backend
 
 
-def backend_run(func: Callable, args: Iterable = None, kwargs: Dict = None, log_path: str or Path = None):
+def backend_run(func: Callable, args: Iterable = None, kwargs: dict = None, log_path: str or Path = None):
     """
     Create a new process and then run it in background mode
     Built-in data types are recommended for args and kwargs values type
-    if use virtual environment,maybe resulting two process.it's python features.
+    if you use virtual environment,maybe resulting two process.it's python features.
     executing directly in the terminal also results in two processes.
     @params func: callback functions, real business code enter
     @params args: func's args
     @params kwargs: func's kwargs
     @params log_path: record the execution results of the backend,default not save log
     Use:
         class User(object):
```

## simplebox/character.py

```diff
@@ -1,11 +1,13 @@
 # !/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Optional, Callable, Union, Tuple, Iterable, Dict, Mapping, Sequence, Container
+from collections.abc import Container, Iterable, Mapping, Sequence
+from typing import Union, Optional
 
+from ._pypkg import Callable
 from .collection.array import Array
 from .collection.arraylist import ArrayList
 from ._handler._str_handler import _strings
 from .generic import T
 from .number import Integer, Float
 
 
@@ -232,15 +234,15 @@
     def count(self, sub, start: int = 0, end: int = -1) -> Integer:
         return Integer(super(String, self).count(sub, start, end))
 
     def encode(self, encoding: str = 'utf-8', errors: str = 'strict'):
         return super(String, self).encode(encoding, errors)
 
     def endswith(
-            self, suffix: Union[str, Tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
+            self, suffix: Union[str, tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
     ) -> bool:
         return super(String, self).endswith(suffix, start, end)
 
     def expandtabs(self, tabsize: int = 8) -> 'String':
         return String(super(String, self).expandtabs(tabsize))
 
     def find(self, sub: str, start: Optional[int] = 0, end: Optional[int] = -1) -> Integer:
@@ -299,15 +301,15 @@
 
     def lower(self) -> 'String':
         return String(super(String, self).lower())
 
     def lstrip(self, chars: Optional[str] = None) -> 'String':
         return String(super(String, self).lstrip(chars))
 
-    def partition(self, sep: str) -> Tuple['String', 'String', 'String']:
+    def partition(self, sep: str) -> tuple['String', 'String', 'String']:
         s1, s2, s3 = super(String, self).partition(sep)
         return String(s1), String(s2), String(s3)
 
     def removeprefix(self, prefix: str) -> 'String':
         return String(super(String, self).removeprefix(prefix))
 
     def removesuffix(self, suffix: str) -> 'String':
@@ -324,15 +326,15 @@
 
     def rindex(self, sub: str, start: Optional[int] = 0, end: Optional[int] = -1) -> Integer:
         return Integer(super(String, self).rindex(sub, start, end))
 
     def rjust(self, width: int, fillchar: str = ' ') -> 'String':
         return String(super(String, self).rjust(width, fillchar))
 
-    def rpartition(self, sep: str) -> Tuple['String', 'String', 'String']:
+    def rpartition(self, sep: str) -> tuple['String', 'String', 'String']:
         s1, s2, s3 = super(String, self).rpartition(sep)
         return String(s1), String(s2), String(s3)
 
     def rsplit(self, sep: Optional[str] = None, maxsplit: int = -1) -> ArrayList['String']:
         values = ArrayList.of_item(super(String, self).rsplit(sep, maxsplit))
         return values.stream.map(lambda s: String(s)).collect(ArrayList)
 
@@ -344,15 +346,15 @@
         return values.stream.map(lambda s: String(s)).collect(ArrayList)
 
     def splitlines(self, keepends: bool = False) -> ArrayList['String']:
         values = ArrayList.of_item(super(String, self).splitlines(keepends))
         return values.stream.map(lambda s: String(s)).collect(ArrayList)
 
     def startswith(
-        self, prefix: Union[str, Tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
+        self, prefix: Union[str, tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
     ) -> bool:
         return super(String, self).startswith(prefix, start, end)
 
     def strip(self, chars: Optional[str] = None) -> 'String':
         return String(super(String, self).strip(chars))
 
     def swapcase(self) -> 'String':
```

## simplebox/classes.py

```diff
@@ -1,38 +1,38 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import inspect
 from types import GenericAlias
-from typing import Tuple, Type, _Final, List, Optional
+from typing import _Final, Optional
 
 from .exceptions import raise_exception, InstanceException
 
 __all__ = ['ForceType', 'StaticClass', 'Final', 'ConstructorIntercept']
 
 
 class ForceType(object):
     """
-    Given a type as the type of a variable, an exception is thrown if the assigned type is inconsistent with that type.
+    Given a type as the type of variable, an exception is thrown if the assigned type is inconsistent with that type.
 
     Excample:
         class Person:
             age = ForceType(int) # ForceType(int, bool)
             name = ForceType(str)
 
             def __init__(self, age, name):
                 self.age = age
                 self.name = name
 
         tony = Person(15, 'Tony')
         tony.age = '15'  # raise exception
     """
 
-    def __init__(self, *types: Optional[Type]):
+    def __init__(self, *types: Optional[type]):
         self.__can_none = False
-        self.__types: List[Type] = []
+        self.__types: list[type] = []
         self.__types_append = self.__types.append
         self.__types_name = []
         self.__types_name_append = self.__types_name.append
         for t in types:
             if t is None:  # NoneType begin with Python version 3.10+
                 self.__can_none = True
                 self.__types_name_append("NoneType")
@@ -44,18 +44,18 @@
                 self.__types_name_append(self.__get__name(t))
             elif issubclass(t_, GenericAlias):
                 t_g_alias = type(t())
                 self.__types_append(t_g_alias)
                 self.__types_name_append(t_g_alias.__name__)
             else:
                 raise TypeError(f"expected 'type' type class, but found '{t_.__name__}'")
-        self.__types: Tuple[Type, ...] = tuple(self.__types)
+        self.__types: type[type, ...] = tuple(self.__types)
 
     @staticmethod
-    def __get__name(t: Type) -> str:
+    def __get__name(t: type) -> str:
         if issubclass(type(t), _Final):
             return getattr(t, "_name") or getattr(getattr(t, "__origin__"), "__name__")
         else:
             return t.__name__
 
     def __get__(self, instance, cls):
         if instance is None:
```

## simplebox/cmd.py

```diff
@@ -4,15 +4,16 @@
 import inspect
 from abc import ABCMeta, abstractmethod
 
 import ujson as json
 from locale import getpreferredencoding
 from pathlib import Path
 from subprocess import PIPE, Popen, run
-from typing import Any, Dict, Callable
+from typing import Any
+from ._pypkg import Callable
 
 from .character import String, StringBuilder
 from .classes import StaticClass
 from .exceptions import raise_exception
 from .exceptions import EmptyException, CommandException
 from .log import LoggerFactory
 from .utils.objects import ObjectsUtils
@@ -126,15 +127,15 @@
 class CommandAdvice(metaclass=ABCMeta):
 
     def __setattr__(self, key, value):
         if __file__ != inspect.stack()[1].filename:
             return
         self.__dict__[key] = value
 
-    def __init__(self, kwargs: Dict[str, Any], show_log: bool = True):
+    def __init__(self, kwargs: dict[str, Any], show_log: bool = True):
         self.__cmd = None
         self.__cwd = None
         self.start_time = None
         self.end_time = None
         self.__code: int = -1
         self.__err_dict = {}
         self.__out_dict = {}
@@ -209,29 +210,29 @@
     def out(self) -> String:
         """
         Returns standard output
         """
         return String(self.__out)
 
     @property
-    def out_to_dict(self) -> Dict:
+    def out_to_dict(self) -> dict:
         """
         Converts command-line standard output to dict
         """
         return self.__out_dict
 
     @property
     def err(self) -> String:
         """
         Returns standard error
         """
         return String(self.__err)
 
     @property
-    def err_to_dict(self) -> Dict:
+    def err_to_dict(self) -> dict:
         """
         Convert command-line standard error to dict
         """
         return self.__out_dict
 
     @property
     def is_success(self) -> bool:
```

## simplebox/enums.py

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from enum import Enum
-from typing import Dict, TypeVar, Union
+from typing import TypeVar, Union
 
 from .generic import T
 from .utils.enums import EnumUtils
 
 _ET = TypeVar("_ET", bound=Union[Enum])
 
 
@@ -43,15 +43,15 @@
         Gets the enumeration object from the enumeration value
         :param value: Enumerates element value
         :param default: If the default value is not found
         """
         return EnumUtils.get_by_value(cls, value, default)
 
     @classmethod
-    def to_dict(cls) -> Dict[str, T]:
+    def to_dict(cls) -> dict[str, T]:
         """
         Convert the enumeration to a dictionary
         """
         return EnumUtils.to_dict(cls)
 
 
 __all__ = [EnhanceEnum]
```

## simplebox/http.py

```diff
@@ -2,15 +2,18 @@
 # -*- coding:utf-8 -*-
 import traceback
 from copy import deepcopy
 from functools import wraps
 from inspect import getfullargspec
 from pathlib import Path
 from time import sleep
-from typing import List, Dict, Callable, Any, Type, Optional, MutableMapping, Union, Tuple
+
+from ._pypkg import Callable
+from collections.abc import MutableMapping
+from typing import Optional, Union, Any
 from urllib.parse import urljoin, urlparse
 
 import regex as re
 import ujson as json
 from requests import Response, Session
 from urllib3 import Retry
 
@@ -62,15 +65,15 @@
             string for the :class:`Request`.
     :param data: (optional) Dictionary, list of tuples, bytes, or file-like
         object to send in the body of the :class:`Request`.
     :param json: (optional) json to send in the body of the
         :class:`Request`.
     :param headers: (optional) Dictionary of HTTP Headers to send with the
         :class:`Request`.
-    :param cookies: (optional) Dict or CookieJar object to send with the
+    :param cookies: (optional) dict or CookieJar object to send with the
         :class:`Request`.
     :param files: (optional) Dictionary of ``'filename': file-like-objects``
         for multipart encoding upload.
     :param auth: (optional) Auth tuple or callable to enable
         Basic/Digest/Custom HTTP Auth.
     :param timeout: (optional) How long to wait for the server to send
         data before giving up, as a float, or a :ref:`(connect timeout,
@@ -87,23 +90,23 @@
         to a CA bundle to use. Defaults to ``True``. When set to
         ``False``, requests will accept any TLS certificate presented by
         the server, and will ignore hostname mismatches and/or expired
         certificates, which will make your application vulnerable to
         man-in-the-middle (MitM) attacks. Setting verify to ``False``
         may be useful during local development or testing.
     :param cert: (optional) if String, path to ssl client cert file (.pem).
-        If Tuple, ('cert', 'key') pair.
+        If tuple, ('cert', 'key') pair.
     Usage:
         RestOptions(params={}, data={}, ...)
     """
 
-    def __init__(self, params: Dict = None, data: Dict = None, headers: Dict = None, cookies: Dict = None,
-                 files: Dict = None, auth: Tuple = None, timeout: float or tuple = None, allow_redirects: bool = True,
-                 proxies: Dict = None, hooks: Dict = None, stream: bool = None, verify: bool = None, cert: str = None,
-                 json: Dict = None, restful: Dict = None, *args, **kwargs):
+    def __init__(self, params: dict = None, data: dict = None, headers: dict = None, cookies: dict = None,
+                 files: dict = None, auth: tuple = None, timeout: float or tuple = None, allow_redirects: bool = True,
+                 proxies: dict = None, hooks: dict = None, stream: bool = None, verify: bool = None, cert: str = None,
+                 json: dict = None, restful: dict = None, *args, **kwargs):
         super().__init__()
         self.update(params=params, data=data, headers=headers, cookies=cookies, files=files, auth=auth,
                     timeout=timeout, allow_redirects=allow_redirects, proxies=proxies, hooks=hooks, stream=stream,
                     verify=verify, cert=cert, json=json, restful=restful, **kwargs)
 
     @property
     def opts_no_none(self) -> Dictionary:
@@ -185,23 +188,23 @@
         """
         return self.__resp
 
     @property
     def body(self) -> Dictionary:
         return Dictionary(self.__resp.json())
 
-    def to_entity(self, type_reference: Type[Entity]) -> Union[ArrayList[T], T]:
+    def to_entity(self, type_reference: type[Entity]) -> Union[ArrayList[T], T]:
         """
         :param type_reference: JSON converts the target type of the Python object
 
         type_reference example:
 
             @EntityType()
             class Data(Entity):
-                id: List[str]
+                id: list[str]
                 OK: str
                 data: str
 
         response body:
             {"data":"data content","id":[1],"OK":"200"}
 
 
@@ -277,42 +280,42 @@
         type_reference will return custom entity object.
 
         usage:
             type_reference example:
 
                 @EntityType()
                 class Data(Entity):
-                    id: List[str]
+                    id: list[str]
                     OK: str
                     data: str
 
             response body:
                 {"data":"data content","id":[1],"OK":"200"}
 
 
 
             resp = RestFast("http://localhost:8080").api("/hello").opts(RestOptions(params={"id": 1})).send(Method.GET).response().to_entity(Data)
             print(resp)  # Data(id=[1], OK='200', data='data content')
         """
         return RestResponse(self.__resp)
 
     @staticmethod
-    def bulk(content: str) -> Dict:
+    def bulk(content: str) -> dict:
         return Rest.bulk(content)
 
 
 class Rest(object):
     """
     A simple http request frame.
     """
 
-    def __init__(self, file: str = None, server_name: str = None, host: str = None, herders: Dict = None,
-                 cookies: Dict = None, check_status: bool = False, encoding: str = "utf-8", description: str = None,
-                 restful: Dict = None, http2: bool = False, retry_times: int = 10, retry_interval: int = 5,
-                 retry_exit_code_range: List = None, retry_exception_retry: bool = True,
+    def __init__(self, file: str = None, server_name: str = None, host: str = None, herders: dict = None,
+                 cookies: dict = None, check_status: bool = False, encoding: str = "utf-8", description: str = None,
+                 restful: dict = None, http2: bool = False, retry_times: int = 10, retry_interval: int = 5,
+                 retry_exit_code_range: list = None, retry_exception_retry: bool = True,
                  retry_check_handler: Callable[[Any], bool] = None):
         """
             def retry(times: int = 10, interval: int = 5, exit_code_range: list = None, exception_retry: bool = True,
               check_handler: Callable[[Any], bool] = None) -> T:
         Build a request client.
         :param file: The path where the interface configuration file is stored.
                      configuration format：
@@ -348,50 +351,50 @@
         :param server_name: Service name, which allows you to read interface information from the interface
         configuration file.
         """
         self.__restful = None
         self.__check_status: Optional[bool] = None
         self.__encoding: Optional[str] = None
         self.__server_name: Optional[str] = None
-        self.__server_list: Optional[List[Dict[str, str]]] = None
-        self.__server: Optional[Dict[str, Any]] = None
+        self.__server_list: Optional[list[dict[str, str]]] = None
+        self.__server: Optional[dict[str, Any]] = None
         self.__host: Optional[str] = None
-        self.__headers: Optional[Dict[str, str]] = None
-        self.__cookies: Optional[Dict[str, str]] = None
+        self.__headers: Optional[dict[str, str]] = None
+        self.__cookies: Optional[dict[str, str]] = None
         self.__description: Optional[str] = None
         self.__http2: Optional[bool] = None
         self.__session: Optional[Session] = None
         self.__retry_times: Optional[int] = None
         self.__retry_interval: Optional[int] = None
-        self.__retry_exit_code_range: Optional[List] = None
+        self.__retry_exit_code_range: Optional[list] = None
         self.__retry_exception_retry: Optional[bool] = None
         self.__retry_check_handler: Optional[Callable[[Any], bool]] = None
         self.__initialize(file, server_name, host, herders, cookies, check_status, encoding, description, restful,
                           http2, retry_times, retry_interval, retry_exit_code_range, retry_exception_retry,
                           retry_check_handler)
 
-    def __initialize(self, file: str = None, server_name: str = None, host: str = None, headers: Dict[str, str] = None,
-                     cookies: Dict[str, str] = None, check_status: bool = False, encoding: str = "utf-8",
-                     description: str = None, restful: Dict = None, http2: bool = False, retry_times: int = 10,
-                     retry_interval: int = 5, retry_exit_code_range: List = None, retry_exception_retry: bool = True,
+    def __initialize(self, file: str = None, server_name: str = None, host: str = None, headers: dict[str, str] = None,
+                     cookies: dict[str, str] = None, check_status: bool = False, encoding: str = "utf-8",
+                     description: str = None, restful: dict = None, http2: bool = False, retry_times: int = 10,
+                     retry_interval: int = 5, retry_exit_code_range: list = None, retry_exception_retry: bool = True,
                      retry_check_handler: Callable[[Any], bool] = None):
         self.__restful = restful or RestFul()
         self.__check_status: bool = check_status if isinstance(check_status, bool) else False
         self.__encoding: str = encoding if isinstance(encoding, str) else "utf-8"
         self.__server_name: str = server_name
-        self.__server_list: List[Dict[str, str]] = []
-        self.__server: Dict[str, Dict[Any, Any]] = {}
+        self.__server_list: list[dict[str, str]] = []
+        self.__server: dict[str, dict[Any, Any]] = {}
         self.__host: str = host
-        self.__headers: Dict[str, str] = headers or {}
-        self.__cookies: Dict[str, str] = cookies or {}
+        self.__headers: dict[str, str] = headers or {}
+        self.__cookies: dict[str, str] = cookies or {}
         self.__description: str = description
         self.__http2: bool = http2 if isinstance(http2, bool) else False
         self.__retry_times: int = retry_times if isinstance(retry_times, int) else 10
         self.__retry_interval: int = retry_interval if isinstance(retry_interval, int) else 5
-        self.__retry_exit_code_range: int = retry_times if isinstance(retry_exit_code_range, List) else (i for i in
+        self.__retry_exit_code_range: int = retry_times if isinstance(retry_exit_code_range, list) else (i for i in
                                                                                                          range(200,
                                                                                                                300))
         self.__retry_exception_retry: int = retry_times if isinstance(retry_exception_retry, bool) else True
         self.__retry_check_handler: int = retry_times
         self.__session: Session = Session()
         if http2:
             scheme = urlparse(self.__host).scheme
@@ -446,26 +449,26 @@
 
     @property
     def server_list(self) -> list:
         return self.__server_list
 
     @server_list.setter
     def server_list(self, value):
-        if issubclass(value_type := type(value), List):
+        if issubclass(value_type := type(value), list):
             self.__server_list = value
         else:
             raise TypeError(f"Excepted type is 'str', got a '{value_type.__name__}'")
 
     @property
-    def server(self) -> Dict:
+    def server(self) -> dict:
         return self.__server
 
     @server.setter
     def server(self, value):
-        if issubclass(value_type := type(value), Dict):
+        if issubclass(value_type := type(value), dict):
             self.__server = value
         else:
             raise TypeError(f"Excepted type is 'dict', got a '{value_type.__name__}'")
 
     @property
     def host(self) -> str:
         return self.__host
@@ -525,15 +528,15 @@
 
         def __inner(func):
             @wraps(func)
             def __wrapper(*args, **kwargs):
                 times_ = times if isinstance(times, int) else self.__retry_times
                 interval_ = interval if isinstance(interval, int) else self.__retry_interval
                 exit_code_range_ = exit_code_range if isinstance(exit_code_range,
-                                                                 List) else self.__retry_exit_code_range
+                                                                 list) else self.__retry_exit_code_range
                 exception_retry_ = exception_retry if isinstance(exception_retry,
                                                                  bool) else self.__retry_exception_retry
                 check_handler_ = check_handler if callable(check_handler) else self.__retry_check_handler
 
                 def default_check_body_call_back(res) -> bool:
                     return res and "status" in res and resp["status"] in exit_code_range_
 
@@ -614,15 +617,15 @@
                         return response
                 user = User()
 
 
             type_reference:
                 @EntityType()
                 class Data(Entity):
-                    id: List[str]
+                    id: list[str]
                     OK: str
 
 
                 class User:
                     rest = Rest(host)
 
                     @rest.get(api="/get_user", method=Method.GET, type_reference=Data)
@@ -1089,16 +1092,16 @@
 
     @staticmethod
     def __api_handler(server_dict: dict, api_name) -> T:
         """
         get api info from config
         """
         if "apis" in server_dict:
-            api_list: List[Dict] = server_dict.get("apis")
-            if issubclass(type(api_list), List):
+            api_list: list[dict] = server_dict.get("apis")
+            if issubclass(type(api_list), list):
                 for api in api_list:
                     if isinstance(api, dict) and api.get("apiName") == api_name:
                         return api
         return {}
 
     def __header_handler(self, all_params: dict, method: str = HttpMethod.GET.value,
                          headers_by_config: dict = None, headers_by_kwargs: dict = None):
@@ -1120,15 +1123,15 @@
         if isinstance(headers_by_config, dict):
             headers_.update(headers_by_config)
         if issubclass(type(headers_by_kwargs), dict):
             headers_.update(headers_by_kwargs)
         all_params[_Constant.HEADERS] = headers_
 
     @staticmethod
-    def __header_has_key(headers: Dict, verify_key: str, ignore_case: bool = False) -> bool:
+    def __header_has_key(headers: dict, verify_key: str, ignore_case: bool = False) -> bool:
         if not headers:
             return False
         if ignore_case:
             tmp_verify_key = verify_key.lower()
         else:
             tmp_verify_key = verify_key
         for k in headers.keys():
@@ -1174,28 +1177,28 @@
             desc: str = server_dict.get("desc")
         return desc
 
     @staticmethod
     def __api_desc_handler(default: T, server_dict: dict, api_name, key: str) -> T:
         default_: dict = default
         if not default_ and _Constant.APIS in server_dict:
-            api_list: List[Dict] = server_dict.get(_Constant.APIS)
+            api_list: list[dict] = server_dict.get(_Constant.APIS)
             if not api_list:
                 return default_
             for api in api_list:
                 if isinstance(api, dict) and api.get(_Constant.API_NAME) == api_name:
                     return api.get(key)
         return default_
 
     @staticmethod
     def __build_log_message(origin: StringBuilder, msg: str):
         origin.append(f"\n{msg}\n")
 
     @staticmethod
-    def bulk(content: str) -> Dict:
+    def bulk(content: str) -> dict:
         """
         Convert headers copied from the browser to dicts
         :param content: copied header from the browser
         :return: python dict object
         """
         tmp = {}
         if issubclass(type(content), str):
```

## simplebox/number.py

```diff
@@ -3,15 +3,16 @@
 import inspect
 import math
 import operator
 import types
 from decimal import Decimal, ROUND_HALF_UP
 from functools import reduce
 from math import factorial
-from typing import TypeVar, Union, Container, Iterable
+from typing import TypeVar, Union
+from collections.abc import Container, Iterable
 from operator import abs, neg, or_, pos, rshift, xor, lshift, contains, countOf, indexOf, inv, mod
 
 from ._handler._number_handler._compare import _Compare, _T
 from .collection.arraylist import ArrayList
 from .exceptions import raise_exception
 
 Number = TypeVar("Number", bound=Union[int, float, 'Integer', 'Float'])
```

## simplebox/singleton.py

```diff
@@ -11,17 +11,35 @@
 
 
 class Singleton(metaclass=SingletonMeta):
     """
     singletons base class
     classes that need to implement singletons only need to inherit Singleton
     usage:
-        class Foo(Singleton):
+        class Class(Singleton):
+
             def __init__(self, name):
                 self.name = name
-        f1 = Foo("f1")
-        f2 = Foo("f2)
-        assert id(f1) == id(f2)
-        assert f1.name == f2.name
-        assert f1.name == "f1"
-        assert f2.name == "f1"
+
+
+        def test1():
+            clz = Class("test1")
+            print(clz.name)
+
+
+        def test2():
+            clz = Class("test2")
+            print(clz.name)
+
+
+        t1 = threading.Thread(target=test1)
+        t2 = threading.Thread(target=test2)
+        t1.start()
+        t2.start()
+        t1.join()
+        t2.join()
+
+        output:
+            test1
+            test1
     """
+
```

## simplebox/void.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Iterable
+from collections.abc import Iterable
 
 
 class Void:
     """
     Represents an empty or useless object
     """
```

## simplebox/_handler/_backend_handler/_backend.py

```diff
@@ -6,15 +6,16 @@
 import pickle
 import platform
 from locale import getpreferredencoding
 from pathlib import Path
 from subprocess import Popen, PIPE
 from sys import executable
 from tempfile import gettempdir
-from typing import Callable, Iterable, Dict
+from simplebox._pypkg import Callable
+from collections.abc import Iterable
 
 from ...character import StringBuilder
 from ...config.log import LogConfig
 from ...log import LoggerFactory
 from ...utils.objects import ObjectsUtils
 from ...utils.strings import StringUtils
 from ...classes import Final
```

## simplebox/_handler/_str_handler/_strings.py

```diff
@@ -1,26 +1,26 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import operator
 from operator import eq, ne
-from typing import Type, List, Iterable, Container
+from collections.abc import Iterable, Container
 
 import regex as re
 
 _EMPTY_CODE = '\\s|\\u00a0|\\u0020|\\u3000|\\u200b|\\u200c|\\u200d|\\ufeff|\\ue601'
 _BOOL = {'true': True, 'false': False}
 
 _SPACE_ALL_PATTERN = re.compile(f'({_EMPTY_CODE})*', re.U)
 _SPACE_START_END_PATTERN = re.compile(f'^({_EMPTY_CODE})*|({_EMPTY_CODE})*$', re.U)
 _SPACE_START_PATTERN = re.compile(f'^({_EMPTY_CODE})*', re.U)
 _SPACE_END_PATTERN = re.compile(f'({_EMPTY_CODE})*$', re.U)
 re.purge()
 
 
-def _check_type_by_type(src: Type[str]) -> bool:
+def _check_type_by_type(src: type[str]) -> bool:
     return issubclass(src, (str, bytes))
 
 
 def _check_type_by_obj(src: str) -> bool:
     return issubclass(type(src), (str, bytes))
 
 
@@ -497,15 +497,15 @@
     if not isinstance(default, bool):
         raise TypeError(f'Excepted type "bool", got a "{type(default).__name__}"')
     if not isinstance(src, str):
         raise TypeError(f'Excepted type "str", got a "{type(src).__name__}"')
     return _BOOL.get(src.lower(), default)
 
 
-def splitblack(src: str, maxsplit: int = -1) -> List[str]:
+def splitblack(src: str, maxsplit: int = -1) -> list[str]:
     """
      Cut by a blank string
     """
     return re.sub(_EMPTY_CODE, ',', src).split(',', maxsplit=maxsplit)
 
 
 def abbreviate(src: str, abbrev_marker: str = "...", offset: int = 0, max_width: int = 0) -> str:
```

## simplebox/_hyper/http11/connection.py

```diff
@@ -6,15 +6,15 @@
 Objects that build hyper's connection-level HTTP/1.1 abstraction.
 """
 import logging
 import os
 import socket
 import base64
 
-from collections import Iterable, Mapping
+from collections.abc import Iterable, Mapping
 
 import collections
 from hyperframe.frame import SettingsFrame
 
 from .response import HTTP11Response
 from ..tls import wrap_socket, H2C_PROTOCOL
 from ..common.bufsocket import BufferedSocket
```

## simplebox/_internal/_argparser.py

```diff
@@ -1,17 +1,16 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import re
-from typing import List
 
 # cli options, also the key of the environment variable. The conversion relationship is "--sb-log" to "SBLOG"
 _options_hook_func = ["__sb_log", "__sb_rest", "__sb_property"]
 
 
-def __config_parser(args: List, instance):
+def __config_parser(args: list, instance):
     args.pop(0)
     if not args or len(args) != 1:
         return
     prefix = f"_{instance.__class__.__name__.replace('_', '')}__set_"
     for arg in re.split(";", args[0]):
         kv = arg.split(":")
         if len(kv) < 2:
@@ -21,20 +20,20 @@
 
 
 '''
 The hook function name for each configuration item of the framework begins with "__sb"
 '''
 
 
-def __sb_log(args: List):
+def __sb_log(args: list):
     from simplebox.config.log import LogConfig
     __config_parser(args, LogConfig)
 
 
-def __sb_rest(args: List):
+def __sb_rest(args: list):
     from simplebox.config.rest import RestConfig
     __config_parser(args, RestConfig)
 
 
-def __sb_property(args: List):
+def __sb_property(args: list):
     from simplebox.config.property import PropertyConfig
     __config_parser(args, PropertyConfig)
```

## simplebox/_internal/_banner.py

```diff
@@ -2,24 +2,23 @@
 # -*- coding:utf-8 -*-
 import os
 import platform
 import sys
 from datetime import datetime
 from enum import Enum
 from locale import getpreferredencoding
-from typing import Dict, List
 
 from .. import config
 from ..config.log import LogConfig
 from ..collection.array import Array
 from ..converter import StorageUnit
 from ..utils.computer import Disk
 
 
-def __build_system_banner_info() -> Dict:
+def __build_system_banner_info() -> dict:
     disk = Disk(str(LogConfig.dir.drive))
     system_properties = {
         "Python Version": platform.python_version(),
         "Python Compiler": platform.python_compiler(),
         "System Encoding": sys.getdefaultencoding(),
         "Terminal Encoding": getpreferredencoding(False),
         "OS Version": platform.platform(),
@@ -41,15 +40,15 @@
 
     for file in files:
         name, _ = os.path.splitext(file)
         modules.append(f".{name}")
     return modules
 
 
-def __build_frame_banner_infos() -> List:
+def __build_frame_banner_infos() -> list:
     """
     Contains system properties
     """
     def gen_frame_config_info(class_):
         frame_config_info = {"title": class_.__doc__.strip()}
         frame_config_properties = {}
         frame_config_info["properties"] = frame_config_properties
```

## simplebox/_internal/_method_helper.py

```diff
@@ -1,16 +1,16 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
+from .._pypkg import Callable
 from inspect import getfullargspec
-from typing import Callable, Tuple, Dict, List
 
 _SELF, _CLS = "self", "cls"
 
 
-def func_full_args(func: Callable, args: Tuple, kwargs: Dict) -> Dict:
+def func_full_args(func: Callable, args: tuple, kwargs: dict) -> dict:
     new_params = {}
     func_spec = getfullargspec(func)
 
     tmp_arg_names = func_spec.args
     tmp_arg_values = __copy_args(args)
     tmp_kwarg_kvs = __copy_kwargs(kwargs)
     if len(args) > 0:
@@ -70,24 +70,24 @@
     if func_spec.varargs:
         new_params[func_spec.varargs] = no_choice_values
     if func_spec.varkw:
         new_params[func_spec.varkw] = tmp_kwarg_kvs
     return new_params
 
 
-def __copy_args(args: Tuple or List) -> List:
+def __copy_args(args: tuple or list) -> list:
     if args is None:
         return []
     tmp_args = []
     tmp_args_append = tmp_args.append
     for arg in args:
         tmp_args_append(arg)
     return tmp_args
 
 
-def __copy_kwargs(kwargs: Dict) -> Dict:
+def __copy_kwargs(kwargs: dict) -> dict:
     if kwargs is None:
         return {}
     tmp_kwargs = {}
     for k, v in kwargs.items():
         tmp_kwargs[k] = v
     return tmp_kwargs
```

## simplebox/cache/manager.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import threading
 from threading import RLock
-from typing import Any, Optional, Dict
+from typing import Any, Optional
 
 from .cache import Cache
 from ..classes import StaticClass
 from ..generic import T
 from ..singleton import SingletonMeta
 
 
@@ -102,15 +102,15 @@
                 self.remove(key)
                 return True
             else:
                 return False
         return True
 
     @property
-    def __get_thread_cache_map(self) -> Dict[Any, Cache[T]]:
+    def __get_thread_cache_map(self) -> dict[Any, Cache[T]]:
         t_id = threading.current_thread().ident
         thread_manager = self.__manager_thread.get(t_id)
         if thread_manager is None:
             thread_manager = {}
             self.__manager_thread[t_id] = thread_manager
         return thread_manager
```

## simplebox/collection/array.py

```diff
@@ -1,19 +1,20 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from bisect import insort_left, insort_right, insort, bisect_left, bisect_right, bisect
 from collections import deque
-from typing import Deque, Iterable, Callable
+from collections.abc import Iterable
 
+from .._pypkg import Callable
 from .collectors import Stream
 from ..generic import T
 from ..utils.optionals import Optionals
 
 
-class Array(Deque[T]):
+class Array(deque[T]):
     """
     Two-way queues, which mainly adds streaming operations
     """
 
     def __init__(self, iterable: Iterable[T] = None, factory: Callable = None):
         """
         Initialization by Array.of() or Array.of_item()
```

## simplebox/collection/arraylist.py

```diff
@@ -1,18 +1,19 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from bisect import bisect, bisect_left, insort, insort_right, insort_left, bisect_right
-from typing import Iterable, List, Callable
+from collections.abc import Iterable
 
+from .._pypkg import Callable
 from .collectors import Stream
 from ..generic import T
 from ..utils.optionals import Optionals
 
 
-class ArrayList(List[T]):
+class ArrayList(list[T]):
     """
     A superset of list, which mainly adds streaming operations
     """
 
     def __init__(self, iterable: Iterable[T] = None, factory: Callable = None):
         """
         Initialization by ArrayList.of() or ArrayList.of_item()
```

## simplebox/collection/collections.py

```diff
@@ -1,12 +1,14 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from abc import ABC, abstractmethod
-from typing import Iterable, Callable, List, Dict, Type, Generic, Set, Tuple
+from collections.abc import Iterable, Set
+from typing import Generic
 
+from .._pypkg import Callable
 from ..generic import T, R, K, V, C
 from ..utils.optionals import Optionals
 
 
 def _default_call_return_intact(element: T) -> T:
     return element
 
@@ -146,15 +148,15 @@
         :return:
         """
 
     @abstractmethod
     def dropwhile(self, predicate: Callable[[T], bool] = _default_call_return_true) -> 'Streamable[T]':
         """
         Make an iterator that drops elements from the iterable as long as the predicate is true;
-        afterwards, returns every element. Note, the iterator does not produce any output until the predicate first
+        afterward, returns every element. Note, the iterator does not produce any output until the predicate first
         becomes false, so it may have a lengthy start-up time.
         :param predicate: Process every element of the stream.
         :return:
         """
 
     @abstractmethod
     def takewhile(self, predicate: Callable[[T], bool] = _default_call_return_true) -> 'Streamable[T]':
@@ -184,15 +186,15 @@
         Returns the count of element number in this stream.
         """
 
     @abstractmethod
     def reduce(self, accumulator: Callable[[T, T], R], initializer: T = None) -> Optionals[R]:
         """
         Apply function of two arguments cumulatively to the items of iterable, from left to right,
-        so as to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
+        to reduce the iterable to a single value. For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
         calculates ((((1+2)+3)+4)+5). The left argument, x, is the accumulated value and the right argument, y,
         is the update value from the iterable.
 
         :param accumulator: an associative, non-interfering, stateless function for incorporating
         an additional element into a result
         :param initializer: If the optional initializer is present, it is placed before the items of the iterable
         in the calculation, and serves as a default when the iterable is empty. If initializer is not given and
@@ -276,56 +278,56 @@
     def find_first(self) -> Optionals[T]:
         """
         Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.
         If the stream has no encounter order, then any element may be returned.
         """
 
     @abstractmethod
-    def group(self, predicate: Callable[[T], R] = _default_call_return_intact, collector: Type[Iterable[T]] = list,
-              overwrite: bool = True) -> Dict[K, Iterable[T]]:
+    def group(self, predicate: Callable[[T], R] = _default_call_return_intact, collector: type[Iterable[T]] = list,
+              overwrite: bool = True) -> dict[K, Iterable[T]]:
         """
         Group by criteria.
 
         @:param predicate: grouping rules
         """
 
     @abstractmethod
-    def to_dict(self, k: Callable[[T], K], v: Callable[[T], V], overwrite: bool = True) -> Dict[K, V]:
+    def to_dict(self, k: Callable[[T], K], v: Callable[[T], V], overwrite: bool = True) -> dict[K, V]:
         """
         Converts the stream into a dictionary, the same key will be overwritten
         :param k: the condition for generating the key
         :param v: the condition for generating the value
         :param overwrite: Whether to overwrite, default true.
         """
 
     @abstractmethod
-    def to_list(self) -> List[T]:
+    def to_list(self) -> list[T]:
         """
         Convert the iterator to list.
         same as the collect(list)
         """
 
     @abstractmethod
     def to_set(self) -> Set[T]:
         """
         Convert the iterator to set.
         same as the collect(set)
         """
 
     @abstractmethod
-    def to_tuple(self) -> Tuple[T]:
+    def to_tuple(self) -> tuple[T]:
         """
         Convert the iterator to set.
         same as the collect(tuple)
         """
 
     @abstractmethod
-    def collect(self, collector: Callable[[Iterable[T]], Type[C][T]] or Type[C][T]) -> Type[C][T]:
+    def collect(self, collector: Callable[[Iterable[T]], type[C][T]] or type[C][T]) -> type[C][T]:
         """
-        The A object will be passed into the predicate and the final processing result will be returned
+        The object will be passed into the predicate and the final processing result will be returned
         :param collector: Performs a mutable reduction operation on the elements of this stream using a collector.
         Usage:
             stream.collect(list) => []
 
         """
 
     @abstractmethod
@@ -380,15 +382,16 @@
         """
         Determine whether the current list contains iterable.
                 If it is a custom object, you need to override __eq__ and __hash__.
         :param iterable: Pending iteration objects.
         """
 
     @abstractmethod
-    def partition(self, size: int = 1, collector: Callable[[Iterable[T]], Type[C][T]] or Type[C][T] = list) -> 'Streamable[Type[C][T]]':
+    def partition(self, size: int = 1, collector: Callable[[Iterable[T]], type[C][T]] or type[C][T] = list) \
+            -> 'Streamable[type[C][T]]':
         """
         Divide the list into multiple sub-lists according to the specified size, and form a two-dimensional list
         :param size: partition size, sub-iterable element number
         :param collector: sub-iterable type.
         """
```

## simplebox/collection/collectors.py

```diff
@@ -1,16 +1,18 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
+import platform
 from collections import defaultdict, deque
 from copy import deepcopy
 from functools import reduce
 from itertools import *
 from math import fsum
 from secrets import choice
-from typing import Iterable, Callable, Dict, List, Iterator, Type, Set, Tuple
+from collections.abc import Iterable, Iterator, Set
+from .._pypkg import Callable
 
 from ..collection.collections import Streamable, Setable, _default_call_return_true, _default_call_return_intact
 from ..exceptions import raise_exception
 from ..generic import T, R, K, V, C
 from ..utils.optionals import Optionals
 
 
@@ -155,46 +157,46 @@
         return Optionals.of_none_able(result[0] if result else None)
 
     def find_any(self) -> Optionals[T]:
 
         return Optionals.of_none_able(choice(list(self)))
 
     def group(self, predicate: Callable[[T], R] = _default_call_return_intact,
-              collector: Callable[[Iterable[T]], Iterable[T]] = list, overwrite: bool = True) -> Dict[K, Iterable[T]]:
+              collector: Callable[[Iterable[T]], Iterable[T]] = list, overwrite: bool = True) -> dict[K, Iterable[T]]:
         group_map = defaultdict(collector)
         for key, group in groupby(self, key=predicate):
             if overwrite:
                 group_map[key] = collector(group)
             else:
                 continue
 
         return group_map
 
-    def to_dict(self, k: Callable[[T], K], v: Callable[[T], V], overwrite: bool = True) -> Dict[K, V]:
+    def to_dict(self, k: Callable[[T], K], v: Callable[[T], V], overwrite: bool = True) -> dict[K, V]:
         tmp = {}
         for i in self:
             key = k(i)
             value = v(i)
             if overwrite:
                 tmp[key] = value
             else:
                 if key not in tmp:
                     tmp[key] = value
         return tmp
 
-    def to_list(self) -> List[T]:
+    def to_list(self) -> list[T]:
         return list(self)
 
     def to_set(self) -> Set[T]:
         return set(self)
 
-    def to_tuple(self) -> Tuple[T]:
+    def to_tuple(self) -> tuple[T]:
         return tuple(self)
 
-    def collect(self, collector: Callable[[Iterable[T]], Type[C][T]] or Type[C][T]) -> Type[C][T]:
+    def collect(self, collector: Callable[[Iterable[T]], type[C][T]] or type[C][T]) -> type[C][T]:
         return collector(self.__data)
 
     def sum(self, start: int = 0) -> int or float:
         return sum(self, start=start)
 
     def fsum(self):
         return fsum(self)
@@ -204,15 +206,16 @@
 
     def issubset(self, iterable: Iterable[T]) -> bool:
         return set(self).issubset(iterable)
 
     def issuperset(self, iterable: Iterable[T]) -> bool:
         return set(self).issuperset(iterable)
 
-    def partition(self, size: int = 1, collector: Callable[[Iterable[T]], Type[C][T]] or Type[C][T] = list) -> 'Stream[Type[C][T]]':
+    def partition(self, size: int = 1, collector: Callable[[Iterable[T]], type[C][T]] or type[C][T] = list) \
+            -> 'Stream[type[C][T]]':
         if not isinstance(size, int) or size <= 0:
             length = 1
         else:
             length = size
         p_iterable = list()
         origin = iter(self)
         while True:
```

## simplebox/db/relational/origin/_query.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import List, Callable
+from simplebox._pypkg import Callable
 
 __all__ = ["Filter", "CompareOperator", "none", "not_", "and_", "or_", "xor"]
 
 from simplebox.exceptions import LengthException
 
 
 class Filter:
@@ -77,15 +77,15 @@
 
     def ge(self, right):
         self.__statement.append(f"`{self.__left}` >= %s")
         self.__params.append(right)
         return self
 
     @property
-    def params(self) -> List:
+    def params(self) -> list:
         return self.__params
 
     def __str__(self):
         return " ".join(self.__statement)
 
     def __repr__(self):
         return self.__str__()
```

## simplebox/db/relational/orm/_db.py

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from abc import abstractmethod, ABCMeta
-from typing import List, Type, Dict, Any, Optional
+from typing import Optional, Any
 
 from sqlalchemy import Engine, Result, and_, ColumnElement, UnaryExpression
 from sqlalchemy.orm import scoped_session, registry
 
 from simplebox.db import _execute
 from simplebox.collection.collectors import Stream
 
@@ -88,15 +88,15 @@
                 def __str__(self):
                     return f"object : <id:{self.id} name:{self.name}>"
 
             insert(User(name="Peter", age=18, sex=1))
         """
         self.driver.add(value)
 
-    def insert_batch(self, values: List[Base]) -> Optional[Result[Any]]:
+    def insert_batch(self, values: list[Base]) -> Optional[Result[Any]]:
         """
         batch insert some record
         example:
             class User(Base):
                 __tablename__ = "user"
                 id = Column(Integer, primary_key=True, autoincrement=True, comment="primary key")
                 name = Column(String(32), index=True, nullable=False, comment="user name")
@@ -115,15 +115,15 @@
         """
         if not values:
             return None
         entityType = type(values[0])
         return self.insert_batch_by_dict(entityType, Stream.of_item(values).map(lambda value: value.__dict__).to_list())
 
     @_execute()
-    def insert_batch_by_dict(self, entityType: Type[Base], values: List[Dict]) -> Optional[Result[Any]]:
+    def insert_batch_by_dict(self, entityType: type[Base], values: list[dict]) -> Optional[Result[Any]]:
         """
         batch insert some record
         example:
             class User(Base):
                 __tablename__ = "user"
                 id = Column(Integer, primary_key=True, autoincrement=True, comment="primary key")
                 name = Column(String(32), index=True, nullable=False, comment="user name")
@@ -139,67 +139,67 @@
                     return f"object : <id:{self.id} name:{self.name}>"
             users = [{"name": "Peter", "age": 18, "sex": 1}, {"name": "Alice", "age": 20, "sex": 0)]
             insert_batch(User, users)
         """
         return self.driver.execute(entityType.__table__.insert(), values)
 
     @_execute()
-    def update(self, entityType: Type[Base], filterConditions: Dict, updateValues: Dict):
+    def update(self, entityType: type[Base], filterConditions: dict, updateValues: dict):
         """
         update a record
         :param entityType: the entity object type for which the table corresponds.
         :param filterConditions: filter record from database.
         :param updateValues: to be updated.
         """
         return self.driver.query(entityType).filter_by(**filterConditions).update(updateValues,
                                                                                   synchronize_session=False)
 
-    def update_batch(self, values: List[Base]):
+    def update_batch(self, values: list[Base]):
         """
         batch update some record
         example:
         @see insert_batch
         """
         if not values:
             return None
         entityType = type(values[0])
         self.update_batch_by_dict(entityType, Stream.of_item(values).map(lambda value: value.__dict__).to_list())
 
     @_execute()
-    def update_batch_by_dict(self, entityType: Type[Base], values: List[Dict]):
+    def update_batch_by_dict(self, entityType: type[Base], values: list[dict]):
         """
         batch update some record
         example:
         @see insert_batch_by_dict
         """
         self.driver.bulk_update_mappings(entityType, values)
 
     @_execute()
-    def delete(self, entityType: Type[Base], *filterConditions: ColumnElement[bool], **filterConditionByNames) -> int:
+    def delete(self, entityType: type[Base], *filterConditions: ColumnElement[bool], **filterConditionByNames) -> int:
         """
         delete one or more record.
         """
         return self.driver.query(entityType).filter(*filterConditions).filter_by(**filterConditionByNames).delete()
 
     @_execute(commit=False)
-    def select(self, entityType: Type[Base], *filterConditions: ColumnElement[bool], **filterConditionByNames):
+    def select(self, entityType: type[Base], *filterConditions: ColumnElement[bool], **filterConditionByNames):
         """
         select one or more record.
         :param entityType: the entity object type for which the table corresponds.
         :param filterConditions: SQLAlchemy filter conditions.
         :param filterConditionByNames: SQLAlchemy filter_by conditions.
         example:
             select(User, and_(User.age < 21, User.sex == 0), name="Peter")
             or
             select(User, User.age < 21, User.sex == 0, name="Peter")
         """
         return self.driver.query(entityType).filter(*filterConditions).filter_by(**filterConditionByNames).all()
 
     @_execute(commit=False)
-    def select_order(self, entityType: Type[Base], orders: tuple[UnaryExpression],
+    def select_order(self, entityType: type[Base], orders: tuple[UnaryExpression],
                      *filterConditions: ColumnElement[bool],
                      **filterConditionByNames):
         """
         select one or more record.
         :param entityType: the entity object type for which the table corresponds.
         :param orders: sort fields, usage Base.Column.desc() or Base.Column.asc()
         :param filterConditions: SQLAlchemy filter conditions.
```

## simplebox/decorators/__init__.py

```diff
@@ -1,14 +1,13 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import sys
 from inspect import getmembers, isfunction
 from pathlib import Path
 from threading import RLock
-from typing import List, Dict
 
 from ._cache import _DecoratorsCache
 
 _DECORATORS_IMPL_MAP_KEY = "decorators-impl-map-key"
 _DECORATORS_NAME_KEY = "decorators-name-key"
 _EXCLUDE_MODULES = ("simplebox.decorators", "simplebox.decorators._process", "simplebox.decorators._cache",
                     "simplebox.decorators._hook", "simplebox.decorators._singleton")
@@ -54,19 +53,19 @@
                             self.__decorators_impl_map[f_name.split("__do_")[1]] = {f_object: None}
             except BaseException:
                 pass
         _DecoratorsCache.put(_DECORATORS_IMPL_MAP_KEY, self.__decorators_impl_map)
         _DecoratorsCache.put(_DECORATORS_NAME_KEY, list(self.__decorators_impl_map.keys()))
 
     @property
-    def decorators_impl(self) -> Dict:
+    def decorators_impl(self) -> dict:
         return self.__decorators_impl_map
 
     @property
-    def decorators(self) -> List:
+    def decorators(self) -> list:
         for decorator in self.__decorators_impl_map.keys():
             yield decorator
 
 
 _ScanModule()
 
 __all__ = ["around", "capture", "retry", "retrying", "repeat", "repeating", "single", "validate",
```

## simplebox/decorators/_around.py

```diff
@@ -1,18 +1,19 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
+from .._pypkg import Callable
 from functools import wraps
-from typing import Tuple, Dict, Callable, TypeVar, Union, List
+from typing import TypeVar, Union
 
 from ._hook import _run_hook_func
 from ._process import _do
 from ..generic import T
 
-_TDict = TypeVar("_TDict", bound=Dict)
-_Types = Union[Tuple[Callable], List[Callable], Callable, None]
+_TDict = TypeVar("_TDict", bound=dict)
+_Types = Union[tuple[Callable], list[Callable], Callable, None]
 
 
 def around(before: _Types = None, after: _Types = None, catch: bool = False) -> T:
     """
     Preform facet operations on functions
     It supports injecting the return value of the preceding hook function into the decorated function
     Support to inject the return value of the decorated function into the post hook function.
@@ -183,25 +184,25 @@
         If "before" is an executable object, the hook function is directly executed
     :param after:
         Post hook function.
         reference resources @params before
     """
     def _inner(func):
         @wraps(func)
-        def _wrapper(*args: Tuple, **kwargs: Dict):
+        def _wrapper(*args: tuple, **kwargs: dict):
             return _do(func=func, decorator_name=around.__name__, args=args, kwargs=kwargs,
                        opts={"before": before, "after": after, "catch": catch, "args": args, "kwargs": kwargs,
                              "stacklevel": 7})
 
         return _wrapper
 
     return _inner
 
 
-def __do_around(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_around(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     args_ = args or ()
     kwargs_ = kwargs or {}
     result = None
     _run_hook_func(opts.get("before"), args, kwargs)
     # noinspection PyBroadException
     try:
         result = func(*args_, **kwargs_)
```

## simplebox/decorators/_capture.py

```diff
@@ -1,18 +1,18 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-
+from .._pypkg import Callable
 from functools import wraps
-from typing import Callable, Type, Any, Tuple, Dict, Union, List
+from typing import Union, Any
 
 from ._hook import _run_hook_func
 from ._process import _do
 from ..generic import T
 
-_ExceptionTypes = Union[Type[Exception], Tuple[Type[Exception]], None]
+_ExceptionTypes = Union[type[Exception], tuple[type[Exception]], None]
 
 
 def capture(exception: _ExceptionTypes = BaseException, post: Callable = None) -> T:
     """
     Catch exceptions to decorated functions, including exceptions generated by other decorators.
 
     callback functions can and only support communication via the chain keyword parameter. example: callback() is ok,
@@ -38,23 +38,23 @@
                        opts={"exception": exception, "post": post, "args": args, "kwargs": kwargs, "stacklevel": 7})
 
         return _wrapper
 
     return _inner
 
 
-def __do_capture(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> Any:
+def __do_capture(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None) -> Any:
     exception: _ExceptionTypes = opts.get("exception")
     post: Callable = opts.get("post")
     args_ = args or ()
     kwargs_ = kwargs or {}
     try:
         return func(*args_, **kwargs_)
     except BaseException as e:
-        if issubclass(type(exception), List):
+        if issubclass(type(exception), list):
             e_type = type(e)
             for e_ in exception:
                 if not issubclass(e_type, e_):
                     raise
         else:
             if not issubclass(type(e), exception):
                 raise
```

## simplebox/decorators/_hook.py

```diff
@@ -1,14 +1,16 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
+from collections.abc import Iterable
 from inspect import getfullargspec
-from typing import Callable, Dict, List, Tuple, Iterable
 
+from .._pypkg import Callable
 
-def _run_hook_func(call_obj: Iterable[Callable] or Callable, args: Tuple, kwargs: Dict) -> Dict:
+
+def _run_hook_func(call_obj: Iterable[Callable] or Callable, args: tuple, kwargs: dict) -> dict:
     if not call_obj:
         return {}
     call_list = []
     if issubclass(type(call_obj), Iterable):
         call_list.extend(call_obj)
     else:
         call_list.append(call_obj)
@@ -25,15 +27,15 @@
             call(*hook_args, **kwargs)
         else:
             assert hasattr(call, "__func__"), f"'{func_type_name}' not a callable"
             __hook_params(call.__func__, hook_args, args)
             call.__func__(*hook_args, **kwargs)
 
 
-def __hook_params(call: Callable, hook_args: List, args: Tuple):
+def __hook_params(call: Callable, hook_args: list, args: tuple):
     spec = getfullargspec(call)
     start_index = 0
     if len(spec.args) > 0:
         if len(args) > 0:
             call_qualname = call.__qualname__
             class_name = None
             if "." in call_qualname:
@@ -48,15 +50,15 @@
                     hook_args.append(instance)
                     start_index = 1
 
         for arg in args[start_index:]:
             hook_args.append(arg)
 
 
-def _build_new_params(kwargs: Dict) -> (List, Dict):
+def _build_new_params(kwargs: dict) -> (list, dict):
     t_args = []
     if "args" in kwargs:
         t_args = kwargs.pop("args")
     t_kwargs = {}
     if "kwargs" in kwargs:
         t_kwargs.update(kwargs.pop("kwargs"))
     t_kwargs.update(kwargs)
```

## simplebox/decorators/_loop.py

```diff
@@ -1,20 +1,21 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
+from .._pypkg import Callable
 from functools import wraps
 from time import sleep
-from typing import Type, Callable, Dict, Tuple, List, Union
+from typing import Union
 
 from ._process import _do
 from ..decorators._hook import _run_hook_func
 from ..generic import T, R, U
 from ..log import LoggerFactory
 
 __LOGGER = LoggerFactory.get_logger("retry")
-_ExceptionTypes = Union[Type[Exception], Tuple[Type[Exception]], None]
+_ExceptionTypes = Union[type[Exception], tuple[type[Exception]], None]
 
 
 def retry(frequency: int = 1, interval: int = 1, increasing: int = 0, check: Callable[[R], bool] = lambda r: True,
           ignored_exception: _ExceptionTypes = None, post: Callable[[R, U], None] = None) -> T:
     """
     Provides retry functionality, if function run success, will run once.
     unit second
@@ -51,15 +52,15 @@
                              "ignored_exception": ignored_exception, "post": post, "stacklevel": 7})
 
         return _wrapper
 
     return _inner
 
 
-def retrying(func: Callable, args: Tuple = None, kwargs: Dict = None,
+def retrying(func: Callable, args: tuple = None, kwargs: dict = None,
              frequency: int = 1, interval: int = 1, increasing: int = 0,
              check: Callable[[R], bool] = lambda r: r,
              ignore_exception: _ExceptionTypes = None,
              post: Callable[[R, U], None] = None) -> T:
     """
     if function run success, will run once.
     :param func: The function to be retried.
@@ -110,15 +111,15 @@
         return _wrapper
 
     return _inner
 
 
 def repeating(func, frequency: int = 1, interval: int = 1, increasing: int = 0,
               ignored_exception: _ExceptionTypes = None,
-              args: Tuple = None, kwargs: Dict = None) -> T:
+              args: tuple = None, kwargs: dict = None) -> T:
     """
     Repeat the function, return last result
     :param func: the function to execute
     :param frequency: number of executions
     :param interval: the time between executions, unit seconds
     :param increasing: the incrementing interval
     :param ignored_exception:
@@ -128,15 +129,15 @@
     :return: last execute result
     """
     return __do_repeat(func, args=args or (), kwargs=kwargs or {},
                        opts={"frequency": frequency, "interval": interval, "increasing": increasing,
                              "ignore_exception": ignored_exception, "stacklevel": 4})
 
 
-def __do_retry(func: Callable = None, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> T:
+def __do_retry(func: Callable = None, args: tuple = None, kwargs: dict = None, opts: dict = None) -> T:
     interval: int = opts.get("interval")
     frequency: int = opts.get("frequency")
     increasing: int = opts.get("increasing")
     ignore_exception: _ExceptionTypes = opts.get("ignore_exception")
     post: Callable[[R, U], None] = opts.get("post")
     check: Callable[[R], bool] = opts.get("check")
     args_ = args or ()
@@ -151,15 +152,15 @@
                 __LOGGER.log(level=30, msg=f"check result fail!!!", stacklevel=4)
             __LOGGER.log(level=20, msg=f"run function '{func.__name__}' "
                                        f"fail: retrying {_} time(s)", stacklevel=4)
             sleep(interval)
             interval += increasing
         except BaseException as e:
             e_type = type(e)
-            if issubclass(type(ignore_exception), List):
+            if issubclass(type(ignore_exception), list):
                 for e_ in ignore_exception:
                     if not issubclass(e_type, e_):
                         raise
             else:
                 if ignore_exception and not issubclass(type(e), ignore_exception):
                     raise
             __LOGGER.log(level=20, msg=f"run function '{func.__name__}' exception {type(e).__name__}: {str(e)}."
@@ -168,15 +169,15 @@
             interval += increasing
     else:
         if post:
             post(*args_, **kwargs_)
             _run_hook_func(post, args, kwargs)
 
 
-def __do_repeat(func, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> T:
+def __do_repeat(func, args: tuple = None, kwargs: dict = None, opts: dict = None) -> T:
     stacklevel: int = opts.get("stacklevel")
     interval: int = opts.get("interval")
     frequency: int = opts.get("frequency")
     increasing: int = opts.get("increasing")
     ignored_exception: _ExceptionTypes = opts.get("ignored_exception")
     args_ = args or ()
     kwargs_ = kwargs or {}
```

## simplebox/decorators/_process.py

```diff
@@ -1,18 +1,18 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import sys
-from typing import Any, Dict
-from operator import ne, contains, eq
+from typing import Any
+from operator import contains, eq
 
 from . import _DecoratorsCache, _DECORATORS_NAME_KEY, _DECORATORS_IMPL_MAP_KEY, _STACK_LEVEL_DEFAULT
 from ._tools import AstTools
 
 
-def _do(func, decorator_name, args, kwargs, opts: Dict = None) -> Any:
+def _do(func, decorator_name, args, kwargs, opts: dict = None) -> Any:
     """
     Decorator master. Assign the executor of the decorator.
     :param func: origin function.
     :param decorator_name: the name of the decorator on the function.
     :param args: origin function's args.
     :param kwargs: origin function's kwargs.
     :return: origin function return value
@@ -41,15 +41,15 @@
     for decorator_func, _ in process_map.items():
         process_map[decorator_func] = opts
         break
     result = None
     if decorator_name_list_tmp and decorator_name_list_tmp[-1] == decorator_name:
         stacklevel = _STACK_LEVEL_DEFAULT + (len(decorator_name_list_tmp) - 1) * 2
         for decorator in decorator_name_list_tmp:
-            process_map: Dict = _DecoratorsCache.get(_DECORATORS_IMPL_MAP_KEY)[decorator]
+            process_map: dict = _DecoratorsCache.get(_DECORATORS_IMPL_MAP_KEY)[decorator]
             for decorator_func, decorator_func_opts in process_map.items():
                 if eq("__do_simplelog", decorator_func.__name__):
                     if contains(decorator_func_opts, "stacklevel") and decorator_func_opts.get("stacklevel") is None:
                         decorator_func_opts["stacklevel"] = stacklevel
                 result = decorator_func(func, args=args, kwargs=kwargs, opts=decorator_func_opts)
                 break
     else:
```

## simplebox/decorators/_properties.py

```diff
@@ -1,17 +1,16 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from collections import defaultdict
+from typing import Union, Generic, Optional
 
 import ujson as json
 import os
 from dataclasses import dataclass
 from pathlib import Path
 from threading import RLock
-from typing import Optional, Union, Any, Generic, Dict, List, Type
 
 from dataclasses_json import dataclass_json, Undefined
 
 from ._tools import AstTools
 from ..collection.arraylist import ArrayList
 from ..config.property import PropertyConfig
 from ..exceptions import ValidatorException
@@ -22,23 +21,23 @@
 _PROPERTY_SOURCE = "PropertySource"
 
 
 class _PropertiesManager(metaclass=SingletonMeta):
     __lock = RLock()
 
     def __init__(self):
-        self.__cache: Dict[Type[Entity], ArrayList[Entity]] = {}
+        self.__cache: dict[type[Entity], ArrayList[Entity]] = {}
 
-    def push(self, cls: Type[T], instance: T):
+    def push(self, cls: type[T], instance: T):
         with self.__lock:
             values = self.__cache.get(cls, ArrayList())
             values.append(instance)
             self.__cache[cls] = values
 
-    def pull(self, cls: Type[T], default: T = None) -> Union[ArrayList[T], T]:
+    def pull(self, cls: type[T], default: T = None) -> Union[ArrayList[T], T]:
         with self.__lock:
             instances: Union[ArrayList[T], T] = self.__cache.get(cls, default)
             return instances
 
 
 _cache = _PropertiesManager()
 
@@ -47,44 +46,44 @@
     """
     All entities need to inherit the entire class.
     """
 
     cache: _PropertiesManager = _cache
 
     @classmethod
-    def get(cls: Type[T]) -> Union[ArrayList[T], T]:
+    def get(cls: type[T]) -> Union[ArrayList[T], T]:
         """
         get entity instance.
         it's singleton, the instance is automatically managed.
         """
         return Entity.cache.pull(cls)
 
     @classmethod
-    def build_from_dict(cls: Type[T], data: Union[Dict, List], fixed: bool = False) -> Union[ArrayList[T], T]:
+    def build_from_dict(cls: type[T], data: Union[dict, list], fixed: bool = False) -> Union[ArrayList[T], T]:
         """
         create a temp entity instance from dict,
         if fixed is True, it will be managed by the manager, then use get() method.
         """
         _check_entity(cls, True)
-        if isinstance(data, Dict):
+        if isinstance(data, dict):
             entity = cls.from_dict(data)
             if fixed:
                 _cache.push(cls, entity)
             return entity
         else:
             array = ArrayList()
             for d in data:
                 entity = cls.from_dict(d)
                 array.append(entity)
                 if fixed:
                     _cache.push(cls, entity)
             return array
 
     @classmethod
-    def build_from_json(cls: Type[T], json_str: str, fixed: bool = False) -> Union[ArrayList[T], T]:
+    def build_from_json(cls: type[T], json_str: str, fixed: bool = False) -> Union[ArrayList[T], T]:
         """
         create a temp entity instance from json string,
         if fixed is True, it will be managed by the manager, then use get() method.
         """
         return Entity.build_from_dict(json.loads(json_str), fixed)
 
 
@@ -113,15 +112,15 @@
         _check_entity(cls, True)
         return _build(cls, init=init, repr_=repr, eq=eq, order=order, unsafe_hash=unsafe_hash,
                       frozen=frozen, letter_case=letter_case, undefined=undefined)
 
     return __wrapper
 
 
-def PropertySource(path: Union[Path, str] = None, coding: str = "utf-8", from_dict: Dict = None):
+def PropertySource(path: Union[Path, str] = None, coding: str = "utf-8", from_dict: dict = None):
     """
     Ingress entity tags that automatically assemble attribute values.
     :param from_dict: if not None, will use from_dict to entity and ignore path.
     :param path:  file path.
     If the path is not absolute, the resources path will be read from the PropertyConfig for concatenation.
     If the path is not a file, the name of the entity class is used as the config file name.
     If the given file does not exist, an exception is thrown.
@@ -172,15 +171,15 @@
                                      all Students are not instantiated successfully.
             print(c.students[0].name)  # IndexError: list index out of range
 
     """
 
     def __inner(cls):
         _check_entity(cls)
-        if isinstance(from_dict, Dict):
+        if isinstance(from_dict, dict):
             instance = cls.from_dict(from_dict)
         else:
             default_name = cls.__name__ + ".json"
             if path is None:
                 pathway = PropertyConfig.resources.joinpath(default_name)
             elif issubclass(path_type := type(path), (str, bytes, os.PathLike)):
                 pathway = Path(path)
@@ -208,15 +207,15 @@
         return cls
 
     return __inner
 
 
 def _check_entity(cls, only_entity: bool = False):
     class_name = cls.__name__
-    decorators: List = AstTools(cls).get_decorator_of_class_by_name(class_name)
+    decorators: list = AstTools(cls).get_decorator_of_class_by_name(class_name)
     if not decorators or _ENTITY_TYPE not in decorators:
         raise ValidatorException(f"{class_name}' decorator wrong:'{class_name}' must be decorated '{_ENTITY_TYPE}'.")
     if decorators.count(_ENTITY_TYPE) != 1:
         raise ValidatorException(f"{class_name}' decorator number wrong: '{_ENTITY_TYPE}' "
                                  f"decorator can only have one, but '{class_name}' found multiple.")
     if not only_entity:
         if decorators.count(_PROPERTY_SOURCE) != 1:
```

## simplebox/decorators/_scheduler.py

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from functools import wraps
-from typing import Callable, Tuple, Dict
+from .._pypkg import Callable
 
 from psutil import cpu_count
 
 from ..decorators._process import _do
 from ..generic import T
 from ..scheduler import SchedulerSync, SchedulerAsync, SchedulerSyncProcess, SchedulerAsyncProcess, SchedulerAsyncIO, \
     SchedulerGevent
@@ -100,36 +100,36 @@
                        opts={"cron": cron,  "timezone": timezone, "jitter": jitter, "stacklevel": 7})
 
         return __wrapper
 
     return __inner
 
 
-def __do_scheduler_sync(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_scheduler_sync(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     SchedulerSync(opts.get("cron"), opts.get("pools"), opts.get("timezone"), opts.get("jitter")).run(func, args, kwargs)
 
 
-def __do_scheduler_async(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_scheduler_async(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     SchedulerAsync(opts.get("cron"), opts.get("pools"), opts.get("timezone"), opts.get("jitter"))\
         .run(func, args, kwargs)
 
 
-def __do_scheduler_sync_process(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_scheduler_sync_process(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     SchedulerSyncProcess(opts.get("cron"), opts.get("pools"), opts.get("timezone"), opts.get("jitter"))\
         .run(func, args, kwargs)
 
 
-def __do_scheduler_async_process(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_scheduler_async_process(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     SchedulerAsyncProcess(opts.get("cron"), opts.get("pools"), opts.get("timezone"), opts.get("jitter"))\
         .run(func, args, kwargs)
 
 
-def __do_scheduler_asyncio(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_scheduler_asyncio(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     SchedulerAsyncIO(opts.get("cron"), opts.get("timezone"), opts.get("jitter")).run(func, args, kwargs)
 
 
-def __do_scheduler_gevent(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None):
+def __do_scheduler_gevent(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None):
     SchedulerGevent(opts.get("cron"), opts.get("timezone"), opts.get("jitter")).run(func, args, kwargs)
 
 
 __all__ = [scheduler_sync, scheduler_async, scheduler_sync_process, scheduler_async_process, scheduler_asyncio,
            scheduler_gevent]
```

## simplebox/decorators/_shape.py

```diff
@@ -3,15 +3,16 @@
 import os
 import tempfile
 import timeit
 from cProfile import Profile
 from functools import wraps
 from pathlib import Path
 from pstats import Stats
-from typing import Any, Dict, Tuple, Callable
+from typing import Any
+from .._pypkg import Callable
 
 import psutil
 from flameprof import render, get_out, DEFAULT_FORMAT, DEFAULT_THRESHOLD, DEFAULT_WIDTH, DEFAULT_ROW_HEIGHT, \
     DEFAULT_FONT_SIZE, DEFAULT_LOG_MULT
 
 from ..decorators._process import _do
 from ..generic import T
@@ -131,15 +132,15 @@
                              "stacklevel": 7})
 
         return __wrapper
 
     return __inner
 
 
-def __do_shaper(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> Any:
+def __do_shaper(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None) -> Any:
     sort_stat = opts.get("sort_stats")
     dump_stats = opts.get("dump_stats")
     flame_graphs = opts.get("flame_graphs")
 
     if sort_stat and sort_stat not in _SORT_STATS:
         raise ValueError(f"Excepted sort stats kind in '{_SORT_STATS}', got a '{sort_stat}'")
```

## simplebox/decorators/_simplelog.py

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from functools import wraps
-from typing import Callable, Tuple, Dict
+from .._pypkg import Callable
 
 from . import _STACK_LEVEL_DEFAULT
 from ._process import _do
 from .._internal._method_helper import func_full_args
 from ..config.log import LogLevel
 from ..generic import T
 from ..log._factory import _LoggerWrapper, LoggerFactory
@@ -33,15 +33,15 @@
         def __wrapper(*args, **kwargs):
             return _do(func=func, decorator_name=simplelog.__name__, args=args, kwargs=kwargs,
                        opts={"logger": logger, "level": level, "template": template, "stacklevel": stacklevel})
         return __wrapper
     return __inner
 
 
-def __do_simplelog(func: Callable = None, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> T:
+def __do_simplelog(func: Callable = None, args: tuple = None, kwargs: dict = None, opts: dict = None) -> T:
     full = func_full_args(func, args, kwargs)
     template: str = opts.get("template")
     level: LogLevel = opts.get("level")
     logger: _LoggerWrapper = opts.get("logger", None) or LoggerFactory.get_logger()
     result = None
     exec_status = False
     try:
```

## simplebox/decorators/_ticker.py

```diff
@@ -1,11 +1,12 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from functools import wraps
-from typing import Callable, Tuple, Dict, Any, Union
+from typing import Any, Union
+from .._pypkg import Callable
 
 from ..decorators._process import _do
 from ..generic import T
 from ..scheduler import Ticker
 
 
 def ticker_apply(*, interval: int = 1, loops: int = -1, end_time: Union[int, float] = None,
@@ -68,18 +69,18 @@
                              "duration": duration, "stacklevel": 7})
 
         return __wrapper
 
     return __inner
 
 
-def __do_ticker_apply(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> Any:
+def __do_ticker_apply(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None) -> Any:
     Ticker(interval=opts.get("interval"), loops=opts.get("loops"), end_time=opts.get("end_time"),
            duration=opts.get("duration")).apply_sync(func, args or (), kwargs or {})
 
 
-def __do_ticker_apply_async(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> Any:
+def __do_ticker_apply_async(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None) -> Any:
     Ticker(interval=opts.get("interval"), loops=opts.get("loops"), end_time=opts.get("end_time"),
            duration=opts.get("duration")).apply_async(func, args or (), kwargs or {})
 
 
 __all__ = [ticker_apply, ticker_apply_async]
```

## simplebox/decorators/_tools.py

```diff
@@ -1,14 +1,13 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from _ast import Call, Attribute
 from ast import NodeVisitor, parse
 from collections import defaultdict
 from inspect import getsource
-from typing import List
 
 
 class AstTools:
 
     def __init__(self, target):
         self.__target = target
         self.__decorators = defaultdict(list)
@@ -17,19 +16,19 @@
         for n in node.decorator_list:
             if isinstance(n, Call):
                 name = n.func.attr if isinstance(n.func, Attribute) else n.func.id
             else:
                 name = n.attr if isinstance(n, Attribute) else n.id
             self.__decorators[node.name].append(name)
 
-    def get_decorator_of_function_by_name(self, name) -> List:
+    def get_decorator_of_function_by_name(self, name) -> list:
         node_iter = NodeVisitor()
         node_iter.visit_FunctionDef = self.__visit_hock
         node_iter.visit_Await = self.__visit_hock
         node_iter.generic_visit(parse(getsource(self.__target)))
         return self.__decorators.get(name)
 
-    def get_decorator_of_class_by_name(self, name) -> List:
+    def get_decorator_of_class_by_name(self, name) -> list:
         node_iter = NodeVisitor()
         node_iter.visit_ClassDef = self.__visit_hock
         node_iter.generic_visit(parse(getsource(self.__target)))
         return self.__decorators.get(name)
```

## simplebox/decorators/_validate.py

```diff
@@ -1,12 +1,13 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from datetime import datetime
 from functools import wraps
-from typing import List, Callable, Tuple, Dict, Type, Optional, Union, Any
+from typing import Optional, Union, Any
+from .._pypkg import Callable
 
 from ._process import _do
 from .._internal._method_helper import func_full_args
 from ..classes import ForceType
 from ..generic import T
 from ..valid import StringValidator, CompareValidator, MemberValidator, Validator, ValidatorExecutor
 
@@ -18,23 +19,23 @@
     compare = ForceType(CompareValidator, None)
     string = ForceType(StringValidator, None)
     contain = ForceType(MemberValidator, None)
     contained = ForceType(MemberValidator, None)
     datetime_format = ForceType(str, None)
     empty = ForceType(bool, None)
     not_empty = ForceType(bool, None)
-    types = ForceType(Tuple[Type, ...], None)
-    validators = ForceType(Tuple[Validator, ...], ValidatorExecutor, None)
+    types = ForceType(tuple[type, ...], None)
+    validators = ForceType(tuple[Validator, ...], ValidatorExecutor, None)
 
     def __init__(self, name: str, compare: Optional[CompareValidator] = None, string: Optional[StringValidator] = None,
                  contain: Optional[MemberValidator] = None,
                  contained: Optional[MemberValidator] = None,
                  datetime_format: Optional[str] = None, empty: bool = False, not_empty: bool = False,
-                 types: Optional[Tuple[Type, ...]] = None,
-                 validators: Union[Tuple[Validator, ...], ValidatorExecutor, None] = None):
+                 types: Optional[tuple[type, ...]] = None,
+                 validators: Union[tuple[Validator, ...], ValidatorExecutor, None] = None):
         """
         A metadata object that validates the validity of the parameter.
         :param name: Parameter name. if name is 'return', 'Valid' will apply to the return value.
         :param compare: Verify that the length of the parameter is the same as expected.
         :param string: Verify that the string of the parameter.
         :param contain: Verify that the parameter contains this option. # 'a' in 'b'
         :param contained: Verify that the option (iterable) contains parameters. 'b' in 'a'
@@ -46,23 +47,23 @@
         self.compare: Optional[CompareValidator] = compare
         self.string: Optional[StringValidator] = string
         self.contain: Optional[MemberValidator] = contain
         self.contained: Optional[MemberValidator] = contained
         self.datetime_format: Optional[str] = datetime_format
         self.empty: Optional[bool] = empty
         self.not_empty: Optional[bool] = not_empty
-        self.types: Optional[Tuple[Type, ...]] = types
+        self.types: Optional[tuple[type, ...]] = types
         if types:
-            self.__types_names: List[str] = [t.__name__ for t in types]
+            self.__types_names: list[str] = [t.__name__ for t in types]
         else:
             self.__types_names = []
-        self.validators: Union[Tuple[Validator, ...], ValidatorExecutor, None] = validators
+        self.validators: Union[tuple[Validator, ...], ValidatorExecutor, None] = validators
 
     @property
-    def type_names(self) -> List[str]:
+    def type_names(self) -> list[str]:
         return self.__types_names
 
 
 def validate(*conditions: Valid) -> T:
     """
     Parameters to the validation method/function.
     :param conditions: Validation conditions, a collection of instances of Valid
@@ -99,15 +100,15 @@
                        opts={"conditions": conditions, "stacklevel": 7})
 
         return __wrapper
 
     return __inner
 
 
-def __do_validate(func: Callable, args: Tuple = None, kwargs: Dict = None, opts: Dict = None) -> Any:
+def __do_validate(func: Callable, args: tuple = None, kwargs: dict = None, opts: dict = None) -> Any:
     args_ = args or ()
     kwargs_ = kwargs or {}
     func_parameters = func_full_args(func, args_, kwargs_)
     return_validators = []
     return_validators_append = return_validators.append
     for valid in opts.get("conditions", []):
         if not isinstance(valid, Valid):
```

## simplebox/exceptions/_exceptions.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Callable
+from .._pypkg import Callable
 
 
 def raise_exception(cause: BaseException, call: Callable = None):
     """
     Actively throws exceptions.
     :param cause: With the exception object thrown
     :param call: The callback function that executes before the exception is thrown
```

## simplebox/log/_factory.py

```diff
@@ -2,15 +2,14 @@
 # -*- coding:utf-8 -*-
 import os
 import traceback
 from functools import wraps
 from logging import Formatter, Logger, LoggerAdapter
 from platform import system
 from threading import current_thread
-from typing import Type
 
 from ._handler import _TimedRotatingFileHandlerWrapper, _RotatingFileHandlerWrapper, _StreamHandlerWrapper
 from .. import banner
 from ..cache.manager import CacheManager
 from ..classes import ForceType
 from ..config.log import LogConfig, LogLevel
 from ._filter import _SimpleLogFilter
@@ -155,15 +154,15 @@
                     if set_ok:
                         self.__remove()
 
             return __wrapper
 
         return __inner
 
-    def catch(self, exception: Type[BaseException] = BaseException, flag: str = "") -> T:
+    def catch(self, exception: type[BaseException] = BaseException, flag: str = "") -> T:
         """
         catch exception when function runtime happened exception.
         :param flag: content flag.
         :param exception: The exception base class catches
         if the exception occurs if it is a subclass of that exception type, otherwise it does not matter.
         example:
             @log.catch()
```

## simplebox/maps/_hash_map.py

```diff
@@ -1,19 +1,19 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Dict, Callable
+from .._pypkg import Callable
 
 from ..collection.collectors import Stream
 from ..generic import V, K
 from ..maps._map import Map
 
 
 class HashMap(Map[K, V]):
 
-    def __init__(self, dictionary: Dict[K, V] = None, factory: Callable = None, **kw):
+    def __init__(self, dictionary: dict[K, V] = None, factory: Callable = None, **kw):
         """
         The factory is called without arguments to produce
         a new value when a key is not present, in __getitem__ only.
         A HashMap compares equal to a dict with the same items.
         All remaining arguments are treated the same as if they were
         passed to the dict constructor, including keyword arguments.
         """
@@ -37,30 +37,30 @@
             v = self.__factory()
         return v
 
     def __repr__(self):
         return f"{type(self).__name__}({super().__repr__()})"
 
     @staticmethod
-    def of_dictionary(dictionary: Dict[K, V], factory: Callable = None) -> 'HashMap[K, V]':
+    def of_dictionary(dictionary: dict[K, V], factory: Callable = None) -> 'HashMap[K, V]':
         return HashMap(dictionary=dictionary, factory=factory)
 
     @staticmethod
     def of_kwargs(factory: Callable = None, **kwargs) -> 'HashMap[K, V]':
         return HashMap(dictionary=kwargs, factory=factory)
 
     @staticmethod
     def of_empty(factory: Callable = None) -> 'HashMap[K, V]':
         return HashMap(factory=factory)
 
-    def merge(self, other: Dict[K, V]) -> 'HashMap[K, V]':
+    def merge(self, other: dict[K, V]) -> 'HashMap[K, V]':
         return HashMap(dict(self, **other))
 
-    def update(self, other: Dict[K, V], **kwargs: [K, V]) -> 'HashMap[K, V]':
-        if isinstance(other, Dict):
+    def update(self, other: dict[K, V], **kwargs: [K, V]) -> 'HashMap[K, V]':
+        if isinstance(other, dict):
             self.update(other)
         self.update(kwargs)
         return self
 
     def put(self, key: K, value: V) -> V:
         v = self.get(key)
         super().__setitem__(key, value)
```

## simplebox/maps/_map.py

```diff
@@ -1,32 +1,32 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from abc import ABC, abstractmethod
-from typing import Dict, Callable
+from .._pypkg import Callable
 
 from ..collection.collectors import Stream
 from ..generic import V, K
 
 
-class Map(Dict[K, V], ABC):
+class Map(dict[K, V], ABC):
     """
     Abstract interface.
     """
 
     @abstractmethod
-    def merge(self, other: Dict[K, V]) -> 'Map[K, V]':
+    def merge(self, other: dict[K, V]) -> 'Map[K, V]':
         """
         Merge the two dictionaries and return a new Map.
 
         The difference with 'update':
             'merge' returns the new Map object, and 'update' returns the instance itself.
         """
 
     @abstractmethod
-    def update(self, other: Dict[K, V], **kwargs: [K, V]) -> 'Map[K, V]':
+    def update(self, other: dict[K, V], **kwargs: [K, V]) -> 'Map[K, V]':
         """
         D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
         If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
         If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
         In either case, this is followed by: for k in F:  D[k] = F[k]
 
         The difference with 'merge':
```

## simplebox/scheduler/_sched.py

```diff
@@ -1,10 +1,10 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Callable, Tuple, Dict
+from .._pypkg import Callable
 
 from apscheduler.executors.asyncio import AsyncIOExecutor
 from apscheduler.executors.gevent import GeventExecutor
 from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor
 from apscheduler.schedulers.asyncio import AsyncIOScheduler
 from apscheduler.schedulers.background import BackgroundScheduler
 from apscheduler.schedulers.base import BaseScheduler
@@ -16,15 +16,15 @@
 
 _THREAD_POOLS = 20
 _PROCESS_POOLS = int(cpu_count() / 2) or 1
 
 
 class Scheduler:
 
-    def run(self, action: Callable, args: Tuple = None, kwargs: Dict = None):
+    def run(self, action: Callable, args: tuple = None, kwargs: dict = None):
         """
         Execute the scheduler
         :param action: task
         :param args: list of positional arguments to task with
         :param kwargs: dict of keyword arguments to task with
         """
         scheduler: BaseScheduler = getattr(self, f"_{self.__class__.__name__}__scheduler")
```

## simplebox/scheduler/_ticker.py

```diff
@@ -1,13 +1,14 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from inspect import getfullargspec
 from threading import Thread
 from time import time, sleep
-from typing import Callable, Tuple, Dict, Union
+from typing import Union
+from .._pypkg import Callable
 
 
 class Ticker(object):
     """
     A simple timer.
     """
 
@@ -33,15 +34,15 @@
         self.__interval: int = interval
         self.__current_loops: int = 1
         self.__loops: int = loops
         self.__end_time: Union[int, float, None] = end_time
         self.__duration: Union[int, float, None] = duration
         self.__current_duration: float = 0
 
-    def apply_sync(self, task: Callable = None, args: Tuple = None, kwargs: Dict = None):
+    def apply_sync(self, task: Callable = None, args: tuple = None, kwargs: dict = None):
         """
         Synchronize execution tasks.
         The task should not be expected to have a return.
         :param task: task FUNCTION.
         :param args: run task need's args.
         :param kwargs: run task need's kwargs. if kwargs contain 'ticker' key, will assign a Ticker object to it.
 
@@ -54,15 +55,15 @@
         """
         kwargs_ = self.__join_this(task, kwargs or {})
         if issubclass(type(task), Callable):
             return self.__actuator(task, args or (), kwargs_)
         else:
             return self.__actuator_no_call()
 
-    def apply_async(self, task: Callable = None, args: Tuple = None, kwargs: Dict = None):
+    def apply_async(self, task: Callable = None, args: tuple = None, kwargs: dict = None):
         """
         Asynchronous execution of tasks.
         The task should not be expected to have a return.
         :param task: task.
         :param args: task args.
         :param kwargs: task kwargs. if kwargs contain 'ticker' key, will assign a Ticker object to it.
 
@@ -76,15 +77,15 @@
         kwargs_ = self.__join_this(task, kwargs or {})
         if issubclass(type(task), Callable):
             ticker_thread = Thread(target=self.__actuator, args=(task, args or (), kwargs_))
         else:
             ticker_thread = Thread(target=self.__actuator_no_call)
         ticker_thread.start()
 
-    def __actuator(self, task: Callable, args: Tuple, kwargs: Dict):
+    def __actuator(self, task: Callable, args: tuple, kwargs: dict):
         sleep(self.__interval)
         if (0 <= self.__loops < self.__current_loops) \
                 or (self.__end_time and self.__now > self.__end_time) \
                 or (self.__duration and 0 <= self.__duration < self.__current_duration):
             return
         task(*args, **kwargs)
         self.__now = time()
```

## simplebox/utils/computer.py

```diff
@@ -1,32 +1,34 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import os
 import socket
+from collections.abc import KeysView
 from decimal import Decimal, ROUND_HALF_UP
 from pathlib import Path
-from typing import KeysView, Callable, Any, List, Set, Dict, Union, TypeVar
+from typing import TypeVar, Union, Any
 
 from psutil import *
 
+from .._pypkg import Callable
 from ..converter import StorageUnit
 
 P = TypeVar("P", bound=Union[Path, str])
 
 
 class Network(object):
     """
     Network information
     """
 
     def __init__(self):
         self.__host__name: str = self.__get_host_name()
         self.__ip: str = self.__get_ip()
         self.__mac: str = self.__get_mac()
-        self.__addresses: Dict = net_if_addrs()
+        self.__addresses: dict = net_if_addrs()
         self.__network_adapter_names: KeysView = self.__addresses.keys()
 
     @property
     def host_name(self) -> str:
         """
         get hostname
         """
@@ -44,15 +46,15 @@
         """
         Get the MAC address
         Applies to a single NIC, if multiple NICs may be inconsistent with expectations
         """
         return self.__mac
 
     @property
-    def network_adapter_names(self) -> List:
+    def network_adapter_names(self) -> list:
         """
         Gets the names of all network adapters
         """
         return list(self.__network_adapter_names)
 
     def mac_by_adapter_name(self, name: str) -> str:
         """
@@ -131,25 +133,25 @@
     def __get_ipv4_by_adapter_name(self, name: str) -> str:
         return self.__get_ip_by_adapter_name_and_family(name, "AF_INET")
 
     def __get_ipv6_by_adapter_name(self, name: str) -> str:
         return self.__get_ip_by_adapter_name_and_family(name, "AF_INET6")
 
     @staticmethod
-    def __get_ip_by_adapter_name_and_family(name: str, family: str or Set) -> str:
+    def __get_ip_by_adapter_name_and_family(name: str, family: str or set) -> str:
         addresses = net_if_addrs()
         for adapter_ in addresses:
             if adapter_ == name:
                 snic_list = addresses[name]
                 for snic in snic_list:
                     if snic.family.name in family:
                         return snic.address
 
     @staticmethod
-    def __get_mac_by_ip(ip: str, fuzzy: bool = False) -> str or List:
+    def __get_mac_by_ip(ip: str, fuzzy: bool = False) -> str or list:
         snics = Network.__get_snic(
             lambda s, greedy: ((not greedy and s.address == ip) or (greedy and s.address.startswith(ip))), fuzzy)
         if not snics:
             return None
         if fuzzy:
             ips = []
             ips_append = ips.append
@@ -161,15 +163,15 @@
             return ips
         else:
             for snic in snics:
                 if snic.family.name == "AF_LINK":
                     return snic.address
 
     @staticmethod
-    def __get_ip_by_mac(mac: str, family: str, fuzzy: bool = False) -> str or List:
+    def __get_ip_by_mac(mac: str, family: str, fuzzy: bool = False) -> str or list:
         snics = Network.__get_snic(
             lambda s, greedy: ((not greedy and s.address == mac) or (greedy and s.address.startswith(mac))), fuzzy)
         if not snics:
             return None
         if fuzzy:
             ips = []
             ips_append = ips.append
@@ -181,15 +183,15 @@
             return ips
         else:
             for snic in snics:
                 if snic.family.name == family:
                     return snic.address
 
     @staticmethod
-    def __get_snic(condition: Callable[[Any, bool], bool], greedy: bool = False) -> List:
+    def __get_snic(condition: Callable[[Any, bool], bool], greedy: bool = False) -> list:
         snics = []
         snics_append = snics.append
         addresses = net_if_addrs()
         for snic_list in addresses.values():
             for snic in snic_list:
                 if condition(snic, greedy):
                     if greedy:
@@ -246,15 +248,15 @@
     def times_percent(self, interval: int = None):
         """
         Get the percentage of total CPU time consumed
         :param interval: The time interval at which the data is fetched
         """
         return cpu_times_percent(interval, False)
 
-    def times_percent_all(self, interval: int = None) -> List:
+    def times_percent_all(self, interval: int = None) -> list:
         """
         Get the proportion of time spent per CPU
         :param interval: The time interval at which the data is fetched
         """
         return cpu_times_percent(interval, True)
 
     def status(self):
@@ -266,19 +268,19 @@
 
     def freq(self):
         """
         Total CPU frequency
         """
         return cpu_freq(False)
 
-    def freq_all(self) -> List:
+    def freq_all(self) -> list:
         """
         The frequency of each CPU
         """
-        return cpu_freq(True)
+        return list(cpu_freq(True))
 
 
 class Memory(object):
 
     @staticmethod
     def virtual():
         """
@@ -332,27 +334,27 @@
         Percentage of free
         """
         return float(
             Decimal(100 - self.__partition.percent).quantize(Decimal(f'0.{"0" * accuracy}'), rounding=ROUND_HALF_UP))
 
 
 class Process(object):
-    def pids(self) -> List[int]:
+    def pids(self) -> list[int]:
         """
         Returns the currently running processes as a list
         """
         return pids()
 
     def pid_exists(self, pid: int) -> bool:
         """
         Determine whether the given PID exists
         """
         return pid_exists(pid)
 
-    def process_iter(self, attrs: List[str] = None) -> List:
+    def process_iter(self, attrs: list[str] = None) -> list:
         """
         Iterates over the currently running process, returning the Process object for each process
         :param attrs: The process property can be filtered and is a list
         """
         return list(process_iter(attrs))
 
     def get_process(self, pid: int = None, pname: str = None) -> Process:
@@ -363,25 +365,25 @@
         """
         for p in process_iter():
             if pid is not None and p.pid == pid:
                 return p
             elif pname and p.name() == pname:
                 return p
 
-    def cmdline(self, pid: int = None, pname: str = None) -> str:
+    def cmdline(self, pid: int = None, pname: str = None) -> list[str]:
         """
         Gets the command-line arguments that start the process
         :param pid: When the process ID and pname exist at the same time, only pid takes effect
         :param pname: process's name
         """
         p = self.get_process(pid, pname)
         if p:
             return p.cmdline()
 
-    def create_time(self, pid: int = None, pname: str = None) -> str:
+    def create_time(self, pid: int = None, pname: str = None) -> float:
         """
         Get the creation time of the process (timestamp format)
         :param pid: When the process ID and pname exist at the same time, only pid takes effect
         :param pname: process's name
         """
         p = self.get_process(pid, pname)
         if p:
```

## simplebox/utils/enums.py

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from enum import EnumMeta, Enum
-from typing import Dict, TypeVar, Union
+from typing import TypeVar, Union
 
 from ..classes import StaticClass
 from ..collection.array import Array
 from ..generic import T
 
 _EMT = TypeVar("_EMT", bound=Union[EnumMeta])
 _ET = TypeVar("_ET", bound=Union[Enum])
@@ -53,15 +53,15 @@
     def has_value(enum_: _EMT, value: T) -> bool:
         """
         Determines whether the enumeration contains members of the specified value
         """
         return value in Array(iterable=enum_.__members__.values()).stream.map(lambda e: e.value)
 
     @staticmethod
-    def to_dict(enum_: _EMT) -> Dict[str, T]:
+    def to_dict(enum_: _EMT) -> dict[str, T]:
         """
         Convert the enumeration to a dictionary
         """
         members = enum_.__members__
         keys = members.keys()
         values = Array(iterable=members.values()).stream.map(lambda e: e.value)
         return dict(zip(keys, values))
```

## simplebox/utils/locks.py

```diff
@@ -1,15 +1,15 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from contextlib import contextmanager
 from multiprocessing import RLock as PLock
 from multiprocessing import Manager
 from random import choice
 from threading import RLock as TLock
-from typing import Set, TypeVar, List
+from typing import TypeVar
 
 from gevent.lock import RLock as CLock
 
 from ..exceptions import NotFountException
 from ..utils.objects import ObjectsUtils
 
 T = TypeVar("T", TLock, PLock, CLock)
@@ -20,15 +20,15 @@
     lock by variable.
     Theoretically, objects can be locked in this way.
     For example, file locking.
     """
 
     def __init__(self, lock, free):
         self.__lock: T = lock
-        self.__free: List = free
+        self.__free: list = free
 
     def add(self, *obj):
         """
         add element(s)
         """
         ObjectsUtils.check_non_none(obj, RuntimeError("can't be 'None'"))
         self.__lock.acquire()
@@ -95,15 +95,15 @@
 
     @staticmethod
     def process() -> Sentry:
         """
         multi processing lock
         """
         manager = Manager()
-        free: Set = manager.list()
+        free: set = manager.list()
         lock: T = PLock()
         return Sentry(lock, free)
 
     @staticmethod
     def thread() -> Sentry:
         """
         multi thread lock
```

## simplebox/utils/objects.py

```diff
@@ -1,12 +1,12 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 from inspect import stack, getframeinfo, currentframe
 from random import sample
-from typing import Iterable
+from collections.abc import Iterable
 
 import regex as re
 from regex import findall
 
 from ..classes import StaticClass
 from ..exceptions import raise_exception, NonePointerException
 from ..generic import V, T
```

## simplebox/utils/optionals.py

```diff
@@ -1,10 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Generic, Callable, Optional
+from .._pypkg import Callable
+from typing import Generic, Optional
 
 from simplebox.exceptions import raise_exception, NonePointerException
 from simplebox.generic import T, U
 from simplebox.void import Void
 
 
 class Optionals(Generic[T]):
```

## simplebox/utils/strings.py

```diff
@@ -1,10 +1,11 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
-from typing import Iterable, List, Union, Tuple, Optional, Mapping, Sequence, Container
+from collections.abc import Iterable, Container, Mapping, Sequence
+from typing import Union, Optional
 
 from .._handler._str_handler import _strings
 from ..character import String
 from ..classes import StaticClass
 from ..collection.arraylist import ArrayList
 from ..number import Integer, Float
 
@@ -417,15 +418,15 @@
     
     @staticmethod
     def encode(src: str, encoding: str = 'utf-8', errors: str = 'strict'):
         return super(src.encode(encoding, errors))
     
     @staticmethod
     def endswith(
-            src: str, suffix: Union[str, Tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
+            src: str, suffix: Union[str, tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
     ) -> bool:
         return src.endswith(suffix, start, end)
     
     @staticmethod
     def expandtabs(src: str, tabsize: int = 8) -> 'String':
         return String(src.expandtabs(tabsize))
     
@@ -506,15 +507,15 @@
         return String(src.lower())
 
     @staticmethod
     def lstrip(src: str, chars: Optional[str] = None) -> 'String':
         return String(src.lstrip(chars))
 
     @staticmethod
-    def partition(src: str, sep: str) -> Tuple['String', 'String', 'String']:
+    def partition(src: str, sep: str) -> tuple['String', 'String', 'String']:
         s1, s2, s3 = src.partition(sep)
         return String(s1), String(s2), String(s3)
 
     @staticmethod
     def removeprefix(src: str, prefix: str) -> 'String':
         return String(src.removeprefix(prefix))
 
@@ -538,15 +539,15 @@
         return Integer(src.rindex(sub, start, end))
 
     @staticmethod
     def rjust(src: str, width: int, fillchar: str = ' ') -> 'String':
         return String(src.rjust(width, fillchar))
 
     @staticmethod
-    def rpartition(src: str, sep: str) -> Tuple['String', 'String', 'String']:
+    def rpartition(src: str, sep: str) -> tuple['String', 'String', 'String']:
         s1, s2, s3 = src.rpartition(sep)
         return String(s1), String(s2), String(s3)
 
     @staticmethod
     def rsplit(src: str, sep: Optional[str] = None, maxsplit: int = -1) -> ArrayList['String']:
         values = ArrayList.of_item(src.rsplit(sep, maxsplit))
         return values.stream.map(lambda s: String(s)).collect(ArrayList)
@@ -563,15 +564,15 @@
     @staticmethod
     def splitlines(src: str, keepends: bool = False) -> ArrayList['String']:
         values = ArrayList.of_item(src.splitlines(keepends))
         return values.stream.map(lambda s: String(s)).collect(ArrayList)
 
     @staticmethod
     def startswith(
-            src: str, prefix: Union[str, Tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
+            src: str, prefix: Union[str, tuple[str, ...]], start: Optional[int] = 0, end: Optional[int] = -1
     ) -> bool:
         return src.startswith(prefix, start, end)
 
     @staticmethod
     def strip(src: str, chars: Optional[str] = None) -> 'String':
         return String(src.strip(chars))
```

## simplebox/valid/_validator.py

```diff
@@ -1,14 +1,15 @@
 #!/usr/bin/env python
 # -*- coding:utf-8 -*-
 import operator
 import time
 from abc import ABC, abstractmethod
+from collections.abc import Iterable
 from datetime import datetime
-from typing import Tuple, Callable, Optional, Iterable, Any, Type, Set, List, Union
+from typing import Any, Optional, Union, Callable
 
 from ..classes import ForceType
 from ..enums import EnhanceEnum
 from ..exceptions import ValidatorException
 from ..utils.strings import StringUtils
 
 
@@ -57,15 +58,15 @@
                 self.name = name
 
 
         tony = Person(-1, "Tony")  # raise exception
     """
 
     def __init__(self, *validators: Validator):
-        self.__validators: Tuple[Validator] = validators
+        self.__validators: tuple[Validator] = validators
 
     def validate(self, value, message: str = None):
         for validator in self.__validators:
             validator.validate(value, message)
 
 
 class CompareValidator(Validator):
@@ -236,19 +237,19 @@
 
 
         tony = Person(1, "Ami")  # success
         tony = Person(2.0, "Ami") # success
         tony = Person("3", "Ami")  # raise exception
     """
 
-    def __init__(self, *types: Optional[Type]):
-        self.__none_type: Set[None] = set()
+    def __init__(self, *types: Optional[type]):
+        self.__none_type: set[None] = set()
         self.__can_none: bool = False
-        self.__types: Set[Type] = set()
-        self.__type_names: List[str] = []
+        self.__types: set[type] = set()
+        self.__type_names: list[str] = []
         self.__type_names_append = self.__type_names.append
         for t in types:
             if t is None:
                 self.__none_type.add(t)
                 self.__can_none = True
                 self.__type_names_append("NoneType")
             elif not isinstance(t, type):
@@ -296,15 +297,15 @@
 
     def validate(self, value, message: str = None):
         now_ = datetime.now()
         if isinstance(value, datetime):
             difference = (value - now_).microseconds
         elif isinstance(value, str):
             _check(not self.__format, message, ValidatorException(f"Valid error: datetime format is must required."))
-            difference = (datetime.strptime(value, self.__format) - datetime.strptime(now_, self.__format)).microseconds
+            difference = (datetime.strptime(value, self.__format) - datetime.strptime(value, self.__format)).microseconds
         elif isinstance(value, (float, int)):
             difference = value - time.time()
         else:
             difference = 0
         _check(self.__future and difference < 0, message,
                ValidatorException(f"Valid error: Excepted datetime is after, got a before datetime: {value}"))
         _check(self.__past and difference > 0, message,
```

## Comparing `simplebox-0.0.1a188.dist-info/METADATA` & `simplebox-0.0.1a189.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: simplebox
-Version: 0.0.1a188
+Version: 0.0.1a189
 Summary: 简易工具箱。
 Author: fuck
 License: MIT Licence
 Keywords: pip,simplebox,backend,fast,fasttools,box,simple
 Platform: any
 Requires-Python: >=3.9
 Requires-Dist: psutil (==5.9.2)
```

## Comparing `simplebox-0.0.1a188.dist-info/RECORD` & `simplebox-0.0.1a189.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,30 +1,31 @@
-simplebox/__init__.py,sha256=20We1hw6OU8_rzfI-RYwVHsfe-54-Zl3Yp9-WmqgDiw,5191
-simplebox/backend.py,sha256=zJ_FpC0tnwMMvipuwv_Ak2AC2Unq-oeLeHz-4wuRKM0,2063
-simplebox/character.py,sha256=ZIy9uS4wWvv2GGF404p1w6dasf0Zeit1FIl8Ovk6Xwk,17591
-simplebox/classes.py,sha256=H8glWNNzi8ijbDkKhT4TZ7di2BetK2SATJRfiYfNST8,4847
-simplebox/cmd.py,sha256=FavoZvAloUhZD0asic2hWJtHz78-gsWeJMHpM20Sc2o,16948
+simplebox/__init__.py,sha256=LxiJX1UuirC1fN3Zf2I1LQ3SLHwlkpYScUGR5c7Zea4,5191
+simplebox/backend.py,sha256=yR3gveO0iKcTKWKW5K57513u-s7O3oGes84Kp8HUZho,2090
+simplebox/character.py,sha256=NEbQqFmD3rpkl_E3MeES7rRfAmtc_DJHoKcF8GNK92g,17626
+simplebox/classes.py,sha256=llb0GZJ-cpZS5NGj_YdzPzY8nXMXff1iskHOC2D6sL0,4825
+simplebox/cmd.py,sha256=w_7p5mnrTUx09wjooTecEBQp7OLiwwL69VkBZ51RqNc,16962
 simplebox/converter.py,sha256=DZ_sb-ZBIorTZAlpuNyGjxnlPAjtSp7yKMIDSiwws0g,5481
-simplebox/enums.py,sha256=-nLsXJ7pKr-A6uJT_FHDYSjY6CQx0VJABUTnkSP3vbw,1644
+simplebox/enums.py,sha256=KzziG7TboPMIENPrc4HrsUagSEMd4JfLFG6Bn2T0HAs,1638
 simplebox/generic.py,sha256=tBDzlqFHQ7I6bb8_iC9PEqyMaD0sxJee9a7zR3YwxRw,306
-simplebox/http.py,sha256=ESfSSvOnRFwmal9SS572Z23DG9l9jCWsF2rHKoiYsKU,55407
+simplebox/http.py,sha256=HqlPE6QPGn2AUQpBnQY-rq0nJXp7Qdg27C92tRrGzII,55432
 simplebox/jsonparser.py,sha256=zMV14sTgmQn_E2mafTOvlw8SlxXSYUPOQFfeFKOoYk4,3672
-simplebox/number.py,sha256=O4MzkfQL1AADsW3lDuRZZozI9dEy2thc4gvFZaR1ZgM,20248
-simplebox/singleton.py,sha256=JQoPeAMuOnufqnSW6uhOEhgW1w6_zzvDkwo-C1HYY_k,772
-simplebox/void.py,sha256=Fq0lKBVGv4dbM70PftJXERCQ7HZY6KvNxRu3kxura7M,4768
+simplebox/number.py,sha256=fOH2fhSUAC4fpD7j1sGO2UM5jIwEESY5-fdKlONcs_A,20276
+simplebox/singleton.py,sha256=zhyjjhQfg9Y1UYgYFYF31ybNjX0A0oMzBaOG1UZerXo,1006
+simplebox/version.py,sha256=5H3eNzxQOzLT5meyjzOZ1-dg1R9U3h5lCGNzWXwU4Lg,1400
+simplebox/void.py,sha256=D175R-LG5rkb9OqqAcWJAxHqNFuD1vP1qJ64t0b5cf8,4777
 simplebox/_handler/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
 simplebox/_handler/_backend_handler/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
-simplebox/_handler/_backend_handler/_backend.py,sha256=11sFLei6a1Ax4WSWlPjOVspnA-mL2vJecAVAuI9nOWU,8148
+simplebox/_handler/_backend_handler/_backend.py,sha256=5UxRgb2HXO35bU-xZzMxOZTJeEK2cQ1xBLwRWvWOesw,8180
 simplebox/_handler/_backend_handler/_run.py,sha256=emJ3OYWJZfQCmnrWwfP86qGRGGGvxHO36Jzea0iTqFQ,979
 simplebox/_handler/_converter_handler/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
 simplebox/_handler/_converter_handler/_calculator.py,sha256=v9pzqddLKRAcEGzX_NHWWpz7-d7Ih5aKtOiHAweC3j0,741
 simplebox/_handler/_number_handler/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
 simplebox/_handler/_number_handler/_compare.py,sha256=2nB8JL9vZhQIBgharceqVK5K2jVOFjVqt3Y_WiSVwtc,1024
 simplebox/_handler/_str_handler/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
-simplebox/_handler/_str_handler/_strings.py,sha256=ZT4eyHL9suNtINuTWMVprtl0p8mkChiex0sNT1jHVFk,19637
+simplebox/_handler/_str_handler/_strings.py,sha256=pQzO-Y2wMgnv96W7W5EfuTsC6oeaf0CBmBQBfs0Yj-E,19634
 simplebox/_hyper/__init__.py,sha256=eOExb8DKddLt3y5WCCiSiyajfjR39Fa89AitWGoQTjQ,927
 simplebox/_hyper/cli.py,sha256=Y4NL-onBVJgN150juaXpYjOGDpGijIPzQTa-ZjXoSFc,7332
 simplebox/_hyper/compat.py,sha256=DCFAfgRs_WfMo--hUejniQ57dIuhg67MY5ouKZ6zQRc,1746
 simplebox/_hyper/contrib.py,sha256=NXZjzhGFDUNM9VONm5eU6XOXktPT0ZNoF0b-__LTNEk,7259
 simplebox/_hyper/httplib_compat.py,sha256=HA9pQZbkmUL052Ve6B4yq3nQh8G1tmI0-iPgnVCVOtc,4561
 simplebox/_hyper/ssl_compat.py,sha256=9G31f981CA80jHpsRBD7kE_UrQ4MmM8C6fN5aXkieIw,10464
 simplebox/_hyper/tls.py,sha256=fCrmAhQqyopxZAuoYoq50xQFuP8bBFusgehdhmLigZU,5282
@@ -32,37 +33,38 @@
 simplebox/_hyper/common/bufsocket.py,sha256=X0h7noOCeKvpprTrqVtj394qLEs4bJkFFILC848sw1U,8570
 simplebox/_hyper/common/connection.py,sha256=JzrHYV3yHBNFEHQGP8xiC16q4TxJsqNcXfXPht8_Cdk,6700
 simplebox/_hyper/common/decoder.py,sha256=-TKD-LUZuj1TjYqjThEn8g1Qni2I2sdY5GRyeieApfA,1608
 simplebox/_hyper/common/exceptions.py,sha256=DgVBvkaw12zWWUwjz1ppLEWvsKze2axr6nWsSbnDMKs,2088
 simplebox/_hyper/common/headers.py,sha256=ShHAt2QEkjtQsmNP6v0IjT2dezeBn2nXimkUFqY_iUc,9144
 simplebox/_hyper/common/util.py,sha256=JFd64F1yGed69xdhMfM6i3uRBsLupZE9u-kN67zzmiE,1587
 simplebox/_hyper/http11/__init__.py,sha256=_0tuxTuKZz2vc_zBkcTruXOTvQrSVXSKCUee3j9aqnM,108
-simplebox/_hyper/http11/connection.py,sha256=XNgy5AVLsP70HNaVQ35cDjGfJmiSPOpxF1QSUa3asuo,17414
+simplebox/_hyper/http11/connection.py,sha256=On7AAgCLr-h6ytPf15O3Uk8FUHkLY6iRnt449mc_VWw,17418
 simplebox/_hyper/http11/parser.py,sha256=LKnmLmEfq0cNAw9FUJkhFXApxN8ycZTCY0PbdaxCnpU,2679
 simplebox/_hyper/http11/response.py,sha256=shGWjKMJwmPJTGv8Cf8s-4bA6GZJm8VgdtiyNvVHWuw,13165
 simplebox/_hyper/http20/__init__.py,sha256=wQ-PGEj_imz6-fPP3kVSDfcDibVEc7NvMIbUxGo7Fjw,106
 simplebox/_hyper/http20/connection.py,sha256=pzJR82LucvD4pZiIkffqK-qoN4l9TYx7R8D05ge2tGo,34497
 simplebox/_hyper/http20/errors.py,sha256=JA6DJlqoR-euUJ9Iep9_62Ocdy7bg-AxuPB_C5wzn3g,3328
 simplebox/_hyper/http20/exceptions.py,sha256=ttAUNbR1gIoyEIq4pFen_qI_bnlwtbZS1gvFOIRSKjQ,1095
 simplebox/_hyper/http20/response.py,sha256=OBWRlkLrbLNOTtdrjvw0R0WCPLTwHxPqJVUGwy1Lqtg,8315
 simplebox/_hyper/http20/stream.py,sha256=AtMaLZBR9SBNKnx3DSLl_WQw19WZ6Q77FRhOs5bkggs,12428
 simplebox/_hyper/http20/util.py,sha256=214pJoZBENkCtc8yq4cpkys2I_qvQnaIt0agtZoXriQ,1652
 simplebox/_hyper/http20/window.py,sha256=KKQMr07QzwOGvx5t8k_itGuOdtL_BGCCPyJiv7oA0Tw,6309
 simplebox/_internal/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
-simplebox/_internal/_argparser.py,sha256=STAa1nN9i3HZQq0ClFG8AK7otTPa_3u9KvRfVgqazas,1137
-simplebox/_internal/_banner.py,sha256=zqkUNIAgdO-y0q7QpqUmIbizLOalV9UjD1_SiGLiD3s,2618
-simplebox/_internal/_method_helper.py,sha256=ff2E1gJZIT6ll3mBCp_FIJq1H9Oy2DjEKwmytnYLxnA,3532
+simplebox/_internal/_argparser.py,sha256=cpF__7bLKqHGHDS9-S15YBiSeRto7zB6bcW_YFTU0Ow,1112
+simplebox/_internal/_banner.py,sha256=qR9_PZbcDyIOc-Q-hUE78x4Y1oliesWKs829XaxE2Vg,2587
+simplebox/_internal/_method_helper.py,sha256=ktSfoZ1_3wwtvhWpdCZBLfXPJCJyrzN-gPfJh9wISHQ,3515
+simplebox/_pypkg/__init__.py,sha256=ooypGjqZqjxMLKH1JdI_0vyUnWGJxeXSAylar2i0Mho,311
 simplebox/cache/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
 simplebox/cache/cache.py,sha256=2RdgAQWGUVmGVjhyDHoZUfR9xxuYyNJSN3uarsxI6SU,1065
-simplebox/cache/manager.py,sha256=KgS9_ddZTMM80lVAg1nR6xOa8ujb3ljq5S7XG8vU3VA,7482
+simplebox/cache/manager.py,sha256=PCvNuy9uwjnlevrxa-f9W7b4DatIi2oBe0p39Tu0VOE,7476
 simplebox/collection/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
-simplebox/collection/array.py,sha256=49OKqaKxvE95AqEPAf70VYoxDkd76kkQlE3KkmL2KyU,4098
-simplebox/collection/arraylist.py,sha256=klLZF4IWwkNNtTToby6YiUS0r9z0oLEhmD-7DC0nWiQ,4618
-simplebox/collection/collections.py,sha256=8o9TUL3NyIn_1VpqCseTmI0lhxQwMlcuKVClyGTSDHs,18273
-simplebox/collection/collectors.py,sha256=qm1DaCuLHKXF1YEd_EHkBqkcwKvJTZw0UHEa3bbY-mA,8841
+simplebox/collection/array.py,sha256=usDUsnT-SfflZUMmyOIgHFDMo0biOOCNL42p2Dz4y-c,4121
+simplebox/collection/arraylist.py,sha256=z5DJBQzEB8E8BxDPX5pnZhCF8hbGYM8ykiVlcziajzU,4642
+simplebox/collection/collections.py,sha256=YrHyDtR7QYqBbBqPXjtPEhptr8Nn0Nl7TGZEEIliPs0,18303
+simplebox/collection/collectors.py,sha256=NK4JIlkBRN1_527loWa_N9XtNiULIUSdisOUHdE5WBQ,8878
 simplebox/colors/__init__.py,sha256=cEFR7F3LqfcuFQR1fHzGslH-a6Q-c9FphotoBXf3bdY,112
 simplebox/colors/_crayon.py,sha256=iIoZTeWQss64zbd79HjUfSysfpD3oPhOL4AcboodGho,823
 simplebox/colors/_linux.py,sha256=-LOPrGzc_hywzPd564FUVxrPdmhVJn0Z70UmY1M3Trg,980
 simplebox/colors/_unknown.py,sha256=r5wTqdR5SlJnJA5RneKEASTXZh1_ro-T4JMtSkg__6E,1047
 simplebox/colors/_windows.py,sha256=v_gSyzs1C47yCWY72FQGJ2i89ongnSJeH02Omt8NFBQ,1329
 simplebox/config/__init__.py,sha256=iU4kkUJFVDkKkvkhhOqO5fQnF-LfLKZR5bZw9d3bqLE,140
 simplebox/config/log.py,sha256=QNZOb8iS6mo7H5YQgxMjc4g6MtAIMlHYbJK_ShJ5j2g,10063
@@ -71,59 +73,59 @@
 simplebox/config/show.py,sha256=9eG8mAmk0TBPR5xQrgSktyTS2pmv3VnDRkne7djKhjc,529
 simplebox/db/__init__.py,sha256=JyHvzxVnGytfRECNCNLighsEGjlJGapvrELZ_meEcwY,814
 simplebox/db/relational/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
 simplebox/db/relational/origin/__init__.py,sha256=CRqqVazR8qhKd1VNJWkBbCQVHCTN0Evf4TD7FptmPKk,420
 simplebox/db/relational/origin/_db.py,sha256=jxaJTxEEa1Z3rCdsTAG2zohlMtCgHm4ZtzZr1V0QKqQ,3150
 simplebox/db/relational/origin/_mysql.py,sha256=NPIwKwOkygajbf_D1XwpyBfE3bkLB3j4v_cBPBwyS_Q,2157
 simplebox/db/relational/origin/_oracle.py,sha256=WXfXBN8kQHeU6qtomz3Ll_lAIXzzpEQUKAK8_WgNfGM,2171
-simplebox/db/relational/origin/_query.py,sha256=9pWf0iMtARlwAuZ5PuIXCRj6_lhVdRkFqDwj8dA-NGQ,3336
+simplebox/db/relational/origin/_query.py,sha256=AYg9G9b0SFd58K2rZDBxvij8uI1L50Hjyc4MpbUivK0,3340
 simplebox/db/relational/origin/_sqlite.py,sha256=7jLWQqlinPTT-5dun23nLBiPEVU1kQogKBAxnlLmBms,1766
 simplebox/db/relational/orm/__init__.py,sha256=pkNRMHRhqdDbx5Kg52r2AW6-lob7hJwnXsXqMpeRhwY,256
-simplebox/db/relational/orm/_db.py,sha256=G9GL7l4DpDVec7PAyX9kPp2j1jH4KVUGB786Sp_2uuI,8540
+simplebox/db/relational/orm/_db.py,sha256=rH3524vQowDltsM0BnR_ncqJi0zaQg72h5nUoWGXdtY,8522
 simplebox/db/relational/orm/_mysql.py,sha256=q4G9uBjAfi70UhsYW6zrSbnjGEkaCR-pt3YeWbHtesI,1154
 simplebox/db/relational/orm/_oracle.py,sha256=kExE84NkIoY3h2-4y1Fpj2mEJb5aSAGGJGCxL10nGpo,1161
 simplebox/db/relational/orm/_sqlite.py,sha256=c00yr0SkIhaWU1p85yqgzNLSacp8Af_FGBLxTRdmi_M,1082
-simplebox/decorators/__init__.py,sha256=0ItOBkNNUQQPgdBjjGdAGJ0E3TTo_y992qUAz53AnOg,2841
-simplebox/decorators/_around.py,sha256=0aPmQIUQdBKyzOvpr3SvV-sse2PyKpuRbC0-bVbMaJE,7423
+simplebox/decorators/__init__.py,sha256=NGRFrPYXfuW-NmdfE_0OwzA4id2g80qyipDYuOvbiDQ,2810
+simplebox/decorators/_around.py,sha256=xicDTpukX_U5BcCzZTumVQEPMPXzWAHUohLgbSwhM74,7425
 simplebox/decorators/_cache.py,sha256=0EeFT9rH0r-awRUYSqZj5nflsFQ9IIRb8ok_XICOa1c,873
-simplebox/decorators/_capture.py,sha256=O3uen5FgjzzG43u4_PFZkiwTfbzz9mGqapOtiCQIw8A,2449
-simplebox/decorators/_hook.py,sha256=naa9NRV34LppodelMne_mOlkCQXQtefmkfbMmz2nXoQ,2245
-simplebox/decorators/_loop.py,sha256=k8BnbdZvimg2IgwBGmaZk_cLEoBW8K_EahH48ZqfvDc,9273
-simplebox/decorators/_process.py,sha256=R2PisJ-cyn6f_LCJkqdDvfG2OQ-NKpat0fdBClLz_n0,2594
-simplebox/decorators/_properties.py,sha256=cTlmUYEUEPrbpUJq3YEECaIKiW2N0yMGqWU7zOwFM3s,9348
-simplebox/decorators/_scheduler.py,sha256=fqK63lWNMPQBWKSZXwESUEM_Yw7HfdOsgdgY_ybmhLw,5160
-simplebox/decorators/_shape.py,sha256=z2iSM9HE6ySoeqwBOenhyTVZhAzd58xkvNg3ZQ2qFYM,9309
-simplebox/decorators/_simplelog.py,sha256=HwpI137M8jDmWrsZGB5tCuuzVORyX7U4gqLYQgpkVxY,2814
+simplebox/decorators/_capture.py,sha256=-Ff592uYyZD7qUCtYP393IP4K7sHX90zLL8CvseI4vE,2443
+simplebox/decorators/_hook.py,sha256=CvS3Ytd5iNUWWWS25wV7Bf8__x7X5_eubMEf1xgAONg,2258
+simplebox/decorators/_loop.py,sha256=pMjlFMpk1hR-sh6I7S7Unpgkky9XU1EvjJzVkSyR68U,9269
+simplebox/decorators/_process.py,sha256=yVpTz7Qa6B-isjR9YqfZfAABfB4h7OIRpnW-4s1SQ2k,2584
+simplebox/decorators/_properties.py,sha256=RaEAkVREZToEXsvcrZ3C7BGkfa19Ke-fXpt8NBaBO5E,9288
+simplebox/decorators/_scheduler.py,sha256=nZtfsj1Z_eV3w1UQjx6mgfdnwKaJz9WMfiFhXUMhYLI,5149
+simplebox/decorators/_shape.py,sha256=rugJJ5cGShjQp63F6HXRZmRJciRdGj074dwBMYAW56k,9317
+simplebox/decorators/_simplelog.py,sha256=QbrW8xDQzRJivzIastp2UwT6SNvGa0wv69sBdMkvlMc,2803
 simplebox/decorators/_singleton.py,sha256=dWB7Hhi5ZxkiVmUxcvegFlLN15buR3KIQa-OU_gCrAY,1334
-simplebox/decorators/_ticker.py,sha256=hQR-fO4oCJTXIlupeg7pEvT3kaFVQLU53LClQodttiQ,3616
-simplebox/decorators/_tools.py,sha256=B99AFuxhXUAqf7MGGpTonpAyhrVRtXI6k-ANiCqfMYs,1266
-simplebox/decorators/_validate.py,sha256=HUYdDBSADTnVheyavkgy-F00e5_K1Qx5D5300_eapkA,7102
+simplebox/decorators/_ticker.py,sha256=ndoedxhHhLJGAYGTxSsIK7Jn-PV0hU97eMqjC-gCm1s,3624
+simplebox/decorators/_tools.py,sha256=ZE1jLHK6PEJnq5GejcKjcGcwlC9dKl6OMnEJDFc8H9o,1241
+simplebox/decorators/_validate.py,sha256=Wls8JU2HNYfw0-Kyh0zTZ34ddtFZ1bjZMedNa_WeMU0,7098
 simplebox/exceptions/__init__.py,sha256=RN7X7HQYUvrVtwsg_gW-HKF0_mVzCSn0Qyg2eT7anC4,399
-simplebox/exceptions/_exceptions.py,sha256=RGl6nb8GO7lFmcx0Yk0NzCM5RqUuBqcvNSf-sKnqeLA,3403
+simplebox/exceptions/_exceptions.py,sha256=oEZCb_Z9YW9gCs7FK8WcgHPI7_p4I9GcYb8awJGaqa0,3405
 simplebox/log/__init__.py,sha256=8dFU166cl8fA_e2Ju14i_f4wWedcezPPnTiESWU4uC8,189
-simplebox/log/_factory.py,sha256=EWVM1-fd8Axhaikx3bypeto_7U90c-pM8sc95oA1aaI,10691
+simplebox/log/_factory.py,sha256=g3wvnl6EIwT3fpUDVDJYnTWJEKUFOqY2GVQO3vJrn80,10666
 simplebox/log/_filter.py,sha256=EzOAJ7QbSnWfodc5IZdT4l66HycF7pX1rgn2o8CpiAk,648
 simplebox/log/_handler.py,sha256=BBdjfL2H17jWZH-Y45kKqDG8xmAm8k4XWe3I6bmX5T4,4266
 simplebox/maps/__init__.py,sha256=Aj4QwgynFYDKXCGH91nw-FZy0Ayfy4GvGOQyuwfg97Y,143
 simplebox/maps/_dictionary.py,sha256=vcvz1ts5NRwe3RVYF_Ozf3_IzwtesPRBkU5O_VAFPgY,6047
-simplebox/maps/_hash_map.py,sha256=PD05SO3AaYjmP_OxydIQNDu99TnWGYBQWp7Pa3CPsQE,3504
-simplebox/maps/_map.py,sha256=mYYuG2cWu9UEHXEVLHwEo_JOdXvswV3jD3ThKd2Xoiw,3756
+simplebox/maps/_hash_map.py,sha256=kSrih2xsOpHEEBYlvNz1h7ks6r32urbIIlN95MI3sWo,3500
+simplebox/maps/_map.py,sha256=chFa02zxUOlalnIMC3dW5Jq2HAq0DUqDRjREFSbwqjA,3752
 simplebox/scheduler/__init__.py,sha256=790BnO2Q-NnyqZAYfkfJd4NPknPRYkI6HqU1a-8kclM,225
 simplebox/scheduler/_base.py,sha256=ERW0RbnMoUrCh_-nEyQcRtb7N0S7r0-g1GXPJ6hg8ss,2120
-simplebox/scheduler/_sched.py,sha256=s9VAPLz7Gr7sHEYo6vpUCGRFC0huxHKVwTCCpbRuO_8,5879
-simplebox/scheduler/_ticker.py,sha256=IXIVteW8hT0_QcQK77qhe5AHhLD2Cokzvl_vB0DeDEQ,6024
+simplebox/scheduler/_sched.py,sha256=NAXs6CnvhupwZ3UwAZijMmU_-HSvhTMza-9pLaYgB0Y,5868
+simplebox/scheduler/_ticker.py,sha256=31HALf20xz9NnNvFS1RkVBpkzTMB440uImyFBS9wVSc,6032
 simplebox/scheduler/_cron/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
 simplebox/scheduler/_cron/_expressions.py,sha256=fBtOoIHV3wjv9PlKgnALqtccU0U39M3jxE0sbh_gf14,226
 simplebox/scheduler/_cron/_fields.py,sha256=iYBrX15zyYSSwmwDc1fSl0tAux_0OXPBGbzF0Io1eGQ,783
 simplebox/utils/__init__.py,sha256=CtZuEO8oVkrRxwm4_fsQYg0wdQ6o3znWt5v6hZ1BBgc,47
-simplebox/utils/computer.py,sha256=b2QzJNDhNkMuzTacFJsgehLaR4RGXu3HUH2GyY2TEbg,14668
-simplebox/utils/enums.py,sha256=Ou182zufwLrEN6f21GnF7BBMSNgxUU667hTPnKqFzt4,2179
-simplebox/utils/locks.py,sha256=_vvA4npIUHAjnXNbBdjkpdOJfnx3w4s6koDcS1wgbEI,3008
-simplebox/utils/objects.py,sha256=AlzAjkXwTadJYQE5TRKclAmyKiuRjJKIgLAZT9GJgp4,11990
-simplebox/utils/optionals.py,sha256=M6YTbRaGAmbFEjVU8ZDYcl__Vc8hog0ycc_yTLI73vE,3221
-simplebox/utils/strings.py,sha256=l321WC2wrhPf0Nvnk1PmFBHAlUdK5ke6ic-d9r71jCk,19531
+simplebox/utils/computer.py,sha256=wTiMyXXCBCW6GuEKOrjKaTlot2ieHf78SAOSlXzmFZg,14714
+simplebox/utils/enums.py,sha256=rwMAmDqUFy2iJey9v0aThBCAFcR-tKqVI9LELw4BKcw,2173
+simplebox/utils/locks.py,sha256=YNT_ZMV52n9MRsizOYweyxMh5Bb__EC8epJWA-dmXXk,2997
+simplebox/utils/objects.py,sha256=FEECiUsCV9ENU_sqIHdPNIYaGbqTgzOqD5fmwEmqmr8,11999
+simplebox/utils/optionals.py,sha256=96PWIIRq_tgjXI7ljidd6eczTkYp5o8F3E8CcM37NvY,3242
+simplebox/utils/strings.py,sha256=yvdvMVI-ULs-DIWElpmjdYHp9CPLbETc5M-16L9gflk,19546
 simplebox/valid/__init__.py,sha256=7deSv2vW7Wj-83Db3JbO0SZK9Pf-G9pDqbCAgkxr8PI,247
-simplebox/valid/_validator.py,sha256=pOwT7PFpenVe4NN73CdMuAjY_XFnw3G8fxU2EGy_OPg,14663
-simplebox-0.0.1a188.dist-info/METADATA,sha256=ip_ffwk062VCYDlPaKETjas3mv1DnAcEyQNVYCTOvgs,1390
-simplebox-0.0.1a188.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-simplebox-0.0.1a188.dist-info/top_level.txt,sha256=96Ce93hfSG2V2dNspzU_GDarYqtHFh9siA46UaMcdjo,10
-simplebox-0.0.1a188.dist-info/RECORD,,
+simplebox/valid/_validator.py,sha256=Gz_j81FFfn-hSHCsMIox72Pqs2Ln4j4novkj6HseR1I,14668
+simplebox-0.0.1a189.dist-info/METADATA,sha256=bLoA3wam_pBCc4XnVO8gTCClJuYIzT9Bqofpo7iOO2I,1390
+simplebox-0.0.1a189.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+simplebox-0.0.1a189.dist-info/top_level.txt,sha256=96Ce93hfSG2V2dNspzU_GDarYqtHFh9siA46UaMcdjo,10
+simplebox-0.0.1a189.dist-info/RECORD,,
```

